	subtitle	"NIC Stuff"	page;================================================================================================;;  FileName: NICStuff.asm;  Date: 4/7/09;  File Version: 1.5.16;  ;  Author: David M. Flynn;  Company: Oxford V.U.E., Inc.;;============================================================================================; Notes:;;  This file is Network Interface Controller routines.;  There are no custom routines in this file.;;  Segmentation is not supported!;   Any incoming or outgoing data must fit in a simgle ethernet frame.;   Routers are not supported, for security all packets must be to/from this subnet.;;============================================================================================; Revision History;; 1.5.16    4/7/09	Fixed: TFTPPortS for Tx of more than 256 bytes.; 1.5.15    6/16/06	To support UsesRS232BufIO _GIE is cleared durring read/write of NIC; 1.5.14    5/11/05	Optimized code.; 1.5.13    3/31/05	Added ARPsNeverDie; 1.5.12    3/16/05	Added AllowReceiveBroadcast; 1.5.11    3/14/05	Changed Locate_ARP to return MAC:FFFFFFFFFFFF when IP:255;	Added some comments fixed others.; 1.5.10    10/22/04	Optomized some code. ip_recv (0/0), Removed some test code.; 1.5.9     9/21/04	The constant testing now defaults to 0; 1.5.8     4/29/04	Changed TFTPPortS_handler to support read only of any block size (default is still 256);	Added entry points for TFTPPortS_ReadAll and TFTPPortS_Read; 1.5.7     12/29/03	Changed atend, checkflag to #Define, added CheckFlagFileReg equ Flags26; 1.5.6     8/28/03	Added outnic_RBCR0_1;	Changed putnic_checkbyte to use only 1 stack word; 1.5.5     7/4/03	Fixed arp_findfree,arp_find to reduce stack loading to 5 from 6.; 1.5.4     6/8/03	Added conditional UsesTCPIPDataPort.; 1.5.3     5/28/03	Moved EQUs to this file.; 1.5.2     5/20/03	Added UsesUDP conditional.; 1.5.1     4/5/03	Fixed a minor bug in tcp_handler for not using UsesRS232BufIO; 1.5       4/4/03	Added TCPRS232Port, RS232Port_handler is in segment 3 (file:RS232Port.asm); 1.4.1b1   3/4/03	Separated TFTPPortS_handler and TFTPPortE_handler.;	Removed code for port numbers > 255.; 1.4b1     2/21/03	Moved pcol tests and branching to get_ether; 1.3b1      2/9/03	Minor bug fixes. First fully functional version.;	As of 2/9/03 this version has NO known bugs or missing features.;	With all testing messsages off there are d'195' bytes free in this segment.; 1.3a1      2/4/03	Added User Datagram Protocol; 1.2       1/29/03	Added ARP cache and ARP Req.; 1.1.1     1/23/03	Added match_word.; 1.1       10/29/02   Moved standard routines from Ether.asm; 1.0.1     9/17/02	Fisrt rev'd version;;============================================================================================; Conditionals;; testing	DisplaysW_D08, lcd_GotoLineW_D08; ARPtesting	Show arp messages on LCD line 0.; UsesRS232	TXString_D08; HasRTC	set_rtc, read_rtc; CodeMemStrings	StringDispatch	There are two of these.; TTFTPtoSRAM	TFTPPortS_handler	There are two of these.; TTFTPtoEEROM	TFTPPortE_handler;  If both versions of TFTPPort_handler are needed a new port number can be used.; UsesUDP	UDP_Send, put_udp, UDP_recv, udp_handler; ARPsNeverDie	Don't decrement time to live ae_ttl;;============================================================================================; Conditional assembly defaults;	ifndef UsesUDP	constant	UsesUDP=1	endif;	ifndef UsesTCPIPDataPort	constant	UsesTCPIPDataPort=1	endif;	ifndef testing	constant	testing=0	endif;	ifndef AllowReceiveBroadcast	constant	AllowReceiveBroadcast=0	endif;	ifndef ARPsNeverDie	constant	ARPsNeverDie=0	endif;;============================================================================================	ORG	0x0800;; Name	(additional stack words required) Description (Bank In/Bank Out);================================================================================================;calls outside this segment;; Segment 0 calls;DisplaysDot_D08	(1+1+1);DisplaysW_D08	(1+1+1);lcd_GotoLineW_D08	(1+1+0);Disp_Hex_Byte_D08	(1+1+2);Disp_decbyteW_D08	(1+1+2);PrintString_D08	(1+1+2);DelayWmS_D08	(1+0);TXString_D08	(1+1+0);WriteLDO_0_D08	(1+0);; other:;  GOTO	http_recv	;tcp port 80 handler in segment 3;  GOTO	UDP_Term_Handler	;udp port 57 handler in segment 3;  GOTO	UDP_Data_Handler	;udp port 87 handler in segment 3;;segment 1 routines;setnic_addr	(1+0) Set the 'remote DMA' address in the NIC's RAM to be accessed;getnic_addr	(1+0) Get the 'remote DMA' address in the NIC's RAM to be accessed;nicwrap	(0)   Wrap an NIC Rx page number;getnic_data	(1+0) Get data from NIC's RAM into the given buffer;get_ether	(1+5) Get packet into buffer, return length (excl CRC);getnic_byte	(1+0) Return a byte from the NIC RAM;getch_net	(1+0) Get a byte from network buffer; if end, set flag;;check_byte_W	(0)   Add byte to checksum value;check_remip	(1+0) Add remip to checksum value;check_MyIP	(1+0) Add myip to checksum value;check_4Data	(1+0) Add 4 bytes pointed to by W to checksum value;check_data	(1+0) Sends bytes from Param7A to Param7A+Param79-1 to checksum value;;get_remip	(1+1) Gets remip with getch_net;get_rseq	(1+1) Gets rseq with getch_net;get_6Data	(1+1) Gets 6 bytes pointed to by W with getch_net;get_2Data	(1+1) Gets 2 bytes pointed to by W with getch_net;get_rack	(1+1) Gets rack with getch_net;get_4Data	(1+1) Gets 4 bytes pointed to by W with getch_net;get_Ndata	(1+1) Gets W bytes pointed to by Param7A with getch_net;get_data	(1+1) gets bytes with getch_net and saves them to Param7A..Param7A+Param79-1;;MemMove_Low	(0)   Move bytes from bank 0 or 1 to somewhere else in bank 0 or 1; MemMove_Low_L	(0)   Move bytes from bank (IRP) to somewhere else in bank (IRP), set IRP before calling.;MemMove_SRAM	(1+1) Move bytes from bank 0 or 1 to SRAM; MemMove_SRAM_L	(1+1) Move bytes from bank (IRP) to SRAM, set IRP before calling.;MemMoveFrom_SRAM	(1+1) Move bytes from SRAM to bank 0 or 1; MemMoveFrom_SRAM_L	(1+1) Move bytes from SRAM to bank (IRP), set IRP before calling.;MemComp_SRAM	(1+1) Compare bytes from bank 0 or 1 to SRAM, return 0 not matched; MemComp_SRAM_L	(1+1) Compare bytes from bank (IRP) to SRAM, return 0 not matched, set IRP before calling.;MemComp_Low	(0)   Compare bytes from bank 0 or 1 to somewhere else in bank 0 or 1, return 0 not matched; MemComp_Low_L	(0)   Compare bytes from bank (IRP) to somewhere else in bank (IRP), return 0 not matched;;match_word	(1+2) Match an incoming word value, return 0 not matched, or end of message;match_byteW	(1+1) Match an incoming byte value, return 0 not matched, or end of message;match_MyIP	(1+2) Match 4 incoming data bytes to data pointed to by W, return 0 not matched, or end of message;match_4Data	(1+2) Match 4 incoming data bytes to data pointed to by W, return 0 not matched, or end of message;match_data	(1+2) matches bytes from getch_net to Param7A..Param7A+Param79-1,  return 0 not matched, or end of message;;skip_6bytes	(1+1) Skip an incoming 6 byte value, return 0 if end of message;skip_lword	(1+1) Skip an incoming lword value, return 0 if end of message;skip_word	(1+1);skip_byte	(1+1);;putch_net_W	(0+0) Put a byte into the network buffer at (txbuff+txin) RAM bank 1;put_rack	(1+0) Sends rack to putch_net_W;put_rseq	(1+0) Sends rseq to putch_net_W;put_remip	(1+0) Sends remip to putch_net_W;put_MyIP	(1+0) Sends myip to putch_net_W;put_4Data	(1+0) Sends 4 bytes pointed to by W to putch_net_W;put_data	(1+0) Sends bytes from Param7A to Param7A+Param79-1 to putch_net_W (banks 0 and 1);put_data2	(1+0) Sends bytes from Param7A to Param7A+Param79-1 to putch_net_W (banks 2 and 3);putnic_data	(1+0) Put the given data into the NIC's RAM;;put_ether	(1+1) Put Ethernet packet into buffer given data at txbuff and len Param7D;xmit_ether	(1+0) Transmit the Ethernet frame;;Locate_ARP	(1+4) Scan the ARP cache for an IP(remip_b0) load into ram if found;arp_findfree	(1+1) Find an free ARP cache record. return: Param78=(0=not found, cache#1..32);arp_find	(1+1) Find an ARP for (ar_spa) in the ARP cache;arp_add_or_replace	(1+2) Add this AR address pair to the cache (replace old if found);arp_add	(1+2) Add a new ARP record to the ARP cache;arp_Replace	(1+2) Move ARP record into SRAM;arp_get	(1+1) Move an ARP record into ram;arp_recv	(1+3) Handle an incoming ARP message;send_ARP_Resp	(1+2) Sends an ARP responce; put_ARP_Header	(1+2) Puts an ARP hearder into the buffer using putch_net_W;send_ARP_Req	(1+3) Sends an ARP request;;UDP_Send	(1+2) Send a UDP datagram given data in txbuff and len txin; UDP_Send_E2	(1+2) Send a UDP datagram;put_udp	(1+1) Put a UDP header into the buffer (txbuff+txin);;put_ip	(1+1) Send out an IP datagram header, given data length;putnic_byte	(1+0) Put the given byte into the NIC's RAM;putnic_checkbyte	(1+0) Put the given byte into the NIC's RAM;;Dec_Put_n_Check	(1+3) combined Fix Dec byte and PutNic Check Byte;DecWPut_n_Check	(1+3) 16 bit version of Dec_Put_n_Check;Dec3BPut_n_Check	(1+3) 24 bit version of Dec_Put_n_Check;;copy_rx_tx	(1+1) Copy a block from NIC Rx to Tx buffers (not crossing page boundaries);;check_rxbytes	(1+0) Checksum the given number of bytes in the Rx NIC buffer;;IncRSeq	(0)   IncRSeq;ip_recv	(1+4++) Get an IP datagram (0/0);tcp_recv	      if valid TCP segment goto tcp_handler; CheckPseudo	(1+1) Check the pseudo header.;tcp_handler	(1++)  Handle an incoming TCP segment;daytime_handler	(1+3) Respond to an Daytime request;;Std_TCP_Setup	(0+1) Clear checksum, setnic_addr((TXSTART*256)+ETHERHEADER_LEN+IPHDR_LEN+TCPHDR_LEN);PutString	(1+2) Send string number (W) to IP frame buffer;TFTPPortS_handler	(1+2) Handler for the TFTP Port SRAM version.;TFTPPortS_ReadAll	(1+2) Read 256 bytes from SRAM into NIC buffer and send it (tflags  Ack & close & Push);TFTPPortS_Read	(1+2) Read SRAM_Len bytes from the SRAM into the nic buffer and send it (tflags  Ack & close & Push);TFTPPortE_handler	(1+2) Handler for the TFTP Port, EEROM version.;TFTPPortE_ReadAll	(1+2) Read eeROMBuffLen bytes of data into NIC buffer and send it (tflags  Ack & close & Push);TFTPPortE_Read	(1+2) Read eeROMbuff.len bytes of data into NIC buffer and send it (tflags  Ack & close & Push);icmp_recv	(1+)  Respond to an ICMP message (e.g. ping);;put_tcp	(1+1) Put out a TCP segment header. Data checksum must have already been computed.;tcp_xmit	(1+2) Transmit a TCP segment; tcp_xmit_2	(1+2) Transmit ethernet header and data;UDP_recv	(1+2++) Test a User Datagram to see if it is valid;udp_handler	(1+2++)    Handle an incomming UDP datagram;;reset_ether	(0)   Set NIC reset signal high (Active);init_ether	(1+4) Initialise NIC.;;innic_NE_RESET	(0)   Input a byte from NIC register NE_RESET;innic_CURRP	(0)   Input a byte from NIC register CURRP, current page reg for rd and wr;innic_ISR	(0)   Input a byte from NIC register ISR, interrupt status reg for rd and wr;innic_RSAR0	(0)   Input a byte from NIC register RSAR0, low byte of remote start addr;innic_RSAR1	(0)   Input a byte from NIC register RSAR1, hi byte of remote start addr;innic_Data	(0)   Input a byte from NIC register DATAPORT;innic	(0)   Input a byte from a NIC register;outnic_RSPR0_W	(0)   Data in W to RSAR0;outnic_RSPR1_W	(0)   Data in W to RSAR1;outnic_BNRY_W	(0)   Data in W to BNRY;outnic_TCR_W	(0)   Data in W to TCR;outnic_RCR_W	(0)   Data in W to RCR;outnic_RBCR1_0	(0)   Set Hi byte of Byte Count to zero;outnic_RBCR1_W	(0)   Set Hi byte of Byte Count;outnic_RBCR0_W	(0)   Set low byte of Byte Count;outnic_CMDR_0A	(0)   Start, DMA remote read;outnic_CMDR_W	(0)   Data in W to CMDR;outnicD78W	(0)   Data in Param78 Address in W;outnic_ISR_FF	(0)   Clear interrupt flags;outnit_ISR_W	(0)   Data in W to ISR;outnic_ISR_0A	(0)   0x0A to ISR;outnic_ISR40	(0)   Clear remote DMA interrupt flag;outnic_ISR	(0)   Write the value in Param71 to the NICs ISR register;outnic_W	(0)   Output a byte to a NIC register W=Addr, Param71=Data;;================================================================================================;========================================================================================================; 8390 Network Interface Controller (NIC) page0 register offsetsCMDR	EQU	0x00	; command register for read & writePSTART	EQU	0x01	; page start register for writePSTOP	EQU	0x02	; page stop register for writeBNRY	EQU	0x03	; boundary reg for rd and wrTPSR	EQU	0x04	; tx start page start reg for wrTBCR0	EQU	0x05	; tx byte count 0 reg for wrTBCR1	EQU	0x06	; tx byte count 1 reg for wrISR	EQU	0x07	; interrupt status reg for rd and wrRSAR0	EQU	0x08	; low byte of remote start addrRSAR1	EQU	0x09	; hi byte of remote start addrRBCR0	EQU	0x0A	; remote byte count reg 0 for wrRBCR1	EQU	0x0B	; remote byte count reg 1 for wrRCR	EQU	0x0C	; rx configuration reg for wrTCR	EQU	0x0D	; tx configuration reg for wrDCR	EQU	0x0E	; data configuration reg for wrIMR	EQU	0x0F	; interrupt mask reg for wr;; NIC page 1 register offsetsPAR0	EQU	0x01	; physical addr reg 0 for rd and wrCURRP	EQU	0x07	; current page reg for rd and wrMAR0	EQU	0x08	; multicast addr reg 0 for rd and WR;; NIC page 3 register offsetsRTL9346CR	EQU	0x01	; RTL 9346 command reg	RTL3	EQU	0x06	; RTL config reg 3;	; NIC RAM definitionsRAMPAGES	EQU	0x20	; Total number of 256-byte RAM pages 20? 40?TXSTART	EQU	0x40	; Tx buffer start page 40?TXPAGES	EQU	0x06	; Pages for Tx buffer 6RXSTART	EQU	(TXSTART+TXPAGES)	; Rx buffer start page 40+6=46RXSTOP	EQU	(TXSTART+RAMPAGES-1)	; Last Rx buffer page 40+20-1=5FDCRVAL	EQU	0x48	; Value for data config reg ;; Command reg values;	EQU	0x0A	;Start, DMA remote read;	EQU	0x12	;Start, DMA remote write;	EQU	0x21	;Stop, DMA abort, page 0;	EQU	0x22	;Start NICNICTXCMD	EQU	0x24	;Transmit the packet;NICDMAAp1CMD	EQU	0x60	;DMA abort, page 1;	EQU	0x61	;Stop, DMA abort, page 1;NICDMAAp0CMD	EQU	0x20	;DMA abort, page 0; NE2000 definitions  DATAPORT 	EQU	0x10 NE_RESET	EQU	0x1F ;; Ethernet definitionsMINFRAME	EQU	d'60' MINFRAMEC	EQU	d'64'	;0x40CRCLEN	EQU	4 MAXFRAME	EQU	d'1514'	;0x5EAMAXFRAMEC	EQU	d'1518'	;0x5EE;;============================================================================================;Dispatch routines (this is segment 1);;segment 0 calls;	if testingDisplaysDot_D08	MOVLW	'.'DisplaysW_D08	mCall1To0	DisplaysW	RETURN;lcd_GotoLineW_D08	mCall1To0	lcd_GotoLineW	RETURN;Disp_Hex_Byte_D08	mCall1To0	Disp_Hex_Byte	RETURN	endif;	if UsesLCDDisp_decbyteW_D08	mCall1To0	Disp_decbyteW	RETURN;PrintString_D08	mCall1To0	PrintString	RETURN	endif		;UsesLCD;DelayWmS_D08	mCall1To0	DelayWmS	RETURN;	if RS232ActiveTXString_D08	mCall1To0	TXString	RETURN	endif;;WriteLDO_0_D08	mCall1To0	WriteLDO_0	RETURN;;=============================================================================================; Set the 'remote DMA' address in the NIC's RAM to be accessed; Entry:nic ram address Low=Param7A, High=Param7B; Exit: none; RAM used: Param71, Param7A, Param7B (verified 1/23/03); Calls: (1+0) outnic_ISR40, outnic_RSPR0_W, outnic_RSPR1_W;  setnic_addr	CALL	outnic_ISR40	;Clear remote DMA interrupt flag	MOVF	Param7A,W	; outnic(RSAR0, addr mod 256); Data addr 	CALL	outnic_RSPR0_W	MOVF	Param7B,W	; outnic(RSAR1, addr/256); 	GOTO	outnic_RSPR1_W; ;==========================================================================	; Get the 'remote DMA' address in the NIC's RAM to be accessed; Entry: none ; Exit: Param79=high byte, W=low byte; RAM used: Param78, Param79 (verified 1/23/03); Calls:(1+0) innic_RSAR1, innic_RSAR0;getnic_addr	CALL	innic_RSAR1	MOVWF	Param79	;move high byte out of harms way	GOTO	innic_RSAR0	;go get low byte and return;; ;==============================================================================================; Wrap an NIC Rx page number; Entry: W=page number to wrap; Exit: W=wraped page munber; RAM used: Param78 (verified 1/23/03); Calls: (0) none;nicwrap	MOVWF	Param78	MOVLW	RXSTOP	; if (page >= RXSTOP) 	SUBWF	Param78,W	BTFSS	STATUS,C	GOTO	nicwrap_1	MOVLW	RXSTART-RXSTOP	; page := page + RXSTART - RXSTOP; 	ADDWF	Param78,F	RETURNnicwrap_1	MOVLW	RXSTART	; else if (page < RXSTART) 	SUBWF	Param78,W	BTFSC	STATUS,C	RETURN	MOVLW	RXSTOP-RXSTART	; page := Page + RXSTOP - RXSTART; 	ADDWF	Param78,W	RETURN		; return(page);; ;==================================================================================================; Get data from NIC's RAM into the given buffer; ptr=Param7A  len=Param7B; Entry: Param7A, Param7B; Exit: none; RAM used: Param71, Param78, Param7A, Param7B, FSR (verified 1/23/03); Calls:(1+0) outnic_ISR40, outnic_RBCR0_W, outnic_RBCR1_0, outnic_CMDR_0A, innic_Data;getnic_data	CALL	outnic_ISR40	; outnic(ISR, 0x40);  Clear remote DMA interrupt flag 	MOVF	Param7B,W	; outnic(RBCR0, len);	Byte count	CALL	outnic_RBCR0_W	CALL	outnic_RBCR1_0	; outnic(RBCR1, 0); 	CALL	outnic_CMDR_0A	; outnic(CMDR, 0x0a);   Start, DMA remote read	MOVF	Param7A,W	MOVWF	FSR	BCF	STATUS,IRP; while (len--)  Get bytesgetnic_data_L1	CALL	innic_Data	; b = innic(DATAPORT); 	MOVWF	INDF	; data^ = b; 	INCF	FSR,F	; data++; 	DECFSZ	Param7B,F	GOTO	getnic_data_L1	RETURN;;===================================================================================================; Get packet into buffer, return length (excl CRC), or 0 if none available; Entry: none; Exit: Param7C=low, Param7D=high; ; RAM used: Param71, Param77, Param78, Param7A, Param7B, Param7C, Param7D, FSR; Calls: (1+5) innic_ISR, innic_CURRP, TXString_D08, init_ether(1+4), outnic_CMDR_W,;	getnic_data, nicwrap, outnic_BNRY_W;get_ether	mBank0	CLRF	rxout+1	; rxout = 0; 	CLRF	rxout	BCF	atend	; atend = 0;;; if (innic(ISR) & 0x10); If Rx overrun..	CALL	innic_ISR	BTFSC	Param78,4	CALL	init_ether	; init_ether(); ..reset controller (drastic!);	MOVLW	0x60	; outnic(CMDR, 0x60) DMA abort, page 1	CALL	outnic_CMDR_W;		CALL	innic_CURRP	;curr = innic(CURRP) Get current page 	MOVLW	0x20	; outnic(CMDR, 0x20) DMA abort, page 0	CALL	outnic_CMDR_W; if (curr != next_page); If Rx packet..	MOVF	next_page,W	SUBWF	Param78,W	SKPNZ	RETURN		;curr=next_page no data so return;  	MOVF	next_page,W	; curr_rx_page = next_page; 	MOVWF	curr_rx_page; setnic_addr(next_page); 	MOVWF	Param7B	;hi byte	CLRF	Param7A	;low byte	CALL	setnic_addr; Move the NIC hardware packet header into ram; getnic_data(&nicin, sizeof(nicin)); 	MOVLW	nicin.nic.stat	;nicin	MOVWF	Param7A	MOVLW	NICETHERHEADER_LEN	;sizeof(nicin) 0x12 bytes	MOVWF	Param7B	;nicin.nic.stat..nicin.eth.pcol+1	CALL	getnic_data;; len = nicin.nic.len; Take length from stored header	MOVF	nicin.nic.len+1,W	;high byte	MOVWF	Param7D	MOVF	nicin.nic.len,W	MOVWF	Param7C; if ((nicin.nic.stat & 1) && len>=MINFRAMEC && len<=MAXFRAMEC) 	BTFSS	nicin.nic.stat,0	GOTO	get_ether_4	;packet error;	MOVF	Param7D,F	SKPZ	GOTO	get_ether_2	;>=0x100;	MOVLW	MINFRAMEC	;<64 bytes	SUBWF	Param7C,W	BTFSS	STATUS,C	GOTO	get_ether_4	;too short packet error	GOTO	get_ether_3	;0x100>len>=MINFRAMEC;get_ether_2	MOVLW	0x05	SUBWF	Param7D,W	BTFSS	STATUS,C	GOTO	get_ether_3	;len<=0x500;	SKPZ	GOTO	get_ether_4	;len>=0x600 too big packet error	MOVLW	0xEF	SUBWF	Param7C,W	BTFSC	STATUS,C	;clr=barrow	GOTO	get_ether_4	;>=0x5EF too big packet error;; If hdr is OK, get packetget_ether_3	MOVLW	2*MACLEN+2+CRCLEN	; len -= MACLEN+MACLEN+2+CRCLEN	SUBWF	Param7C,F	BTFSS	STATUS,C	DECF	Param7D,F ;	MOVF	Param7D,W	; rxin = len;	MOVWF	rxin+1	MOVF	Param7C,W	MOVWF	rxin;	GOTO	get_ether_5;get_ether_4	CLRF	Param7D	; len = 0; 	CLRF	Param7C;;; Update next packet ptr; if (nicin.nic.next>=RXSTART && nicin.nic.next<RXSTOP) get_ether_5	MOVLW	RXSTART	SUBWF	nicin.nic.next,W	BTFSS	STATUS,C	GOTO	get_ether_6	MOVLW	RXSTOP	SUBWF	nicin.nic.next,W	BTFSC	STATUS,C	GOTO	get_ether_6;	MOVF	nicin.nic.next,W	; next_page = nicin.nic.next; 	MOVWF	next_page; else  If invalid, use prev+1	GOTO	get_ether_7;; next_page = nicwrap(next_page + 1); get_ether_6	MOVLW	0x01	ADDWF	next_page,W	CALL	nicwrap	MOVWF	next_page	CLRF	Param7D	; len = 0;	CLRF	Param7C; Update boundary register; bound = nicwrap(next_page - 1); get_ether_7	DECF	next_page,W	; W=next_page-1	CALL	nicwrap	CALL	outnic_BNRY_W	; outnic(BNRY, bound); ;;	MOVF	Param7C,W	; len of data LSB	IORWF	Param7D,W	; len of data MSB	SKPNZ		;skip if len<>0	RETURN;;; Note nicin.eth.pcol is big endian whereas my variables are little endian!		; if (nicin.eth.pcol == PCOL_ARP) 	MOVLW	high PCOL_ARP	SUBWF	nicin.eth.pcol,W	SKPZ	GOTO	get_ether_IP	;hi byte didn't match;	MOVLW	low PCOL_ARP	SUBWF	nicin.eth.pcol+1,W	SKPNZ	GOTO	arp_recv	; it's ARP;; else if (nicin.eth.pcol == PCOL_IP) get_ether_IP	MOVLW	high PCOL_IP	SUBWF	nicin.eth.pcol,W	SKPZ	GOTO	get_ether_Px	;hi byte didn't match;	MOVLW	low PCOL_IP	SUBWF	nicin.eth.pcol+1,W	SKPNZ	GOTO	ip_recv	;it's IP;the next pcol  (there isn't one)get_ether_Px	RETURN;;===============================================================================================	; Return a byte from the NIC RAM; Entry:none; Exit: W & Param78=Data; RAM used: Param71, Param78 (verified 10/2/02); Calls: (1+0) outnic_RBCR0_1, outnic_RBCR1_0, outnic_CMDR_0A, innic_Data;getnic_byte	CALL	outnic_RBCR0_1	; outnic(RBCR0, 1) Byte count	CALL	outnic_RBCR1_0	; outnic(RBCR1, 0); 	CALL	outnic_CMDR_0A	; outnic(CMDR, 0x0a) Start, DMA remote read	GOTO	innic_Data	;  b = innic(DATAPORT); ;  ;======================================================================================================; Get a byte from network buffer; if end, set flag; Entry: rxin, rxout; Exit: rxout++, Param78 & W = byte from nic; RAM used: Param71, Param78 (verified 1/23/03); Calls:(1+0) check_byte_W, outnic_RBCR0_W, outnic_RBCR1_0, outnic_CMDR_0A, innic_Data;getch_net	mBank0	CLRF	Param78	; BYTE b=0; 	BSF	atend	;default to atend	MOVF	rxout+1,W	; atend = rxout>=rxin; 	SUBWF	rxin+1,W	BTFSS	_C	GOTO	getch_net_2	MOVF	rxout+1,W	SUBWF	rxin+1,W	BTFSS	_Z	GOTO	getch_net_1	MOVF	rxout,W	SUBWF	rxin,W	BTFSC	_Z	GOTO	getch_net_2	BTFSS	_C	GOTO	getch_net_2getch_net_1	BCF	atendgetch_net_2	BTFSC	atend	; if (!atend) 	RETLW	0x00	; default value is end of data;----------------;copy of getnic_byte to save a stack word;	CALL	getnic_byte	; b = getnic_byte(); ;getnic_byte	CALL	outnic_RBCR0_1	; outnic(RBCR0, 1) Byte count	CALL	outnic_RBCR1_0	; outnic(RBCR1, 0); 	CALL	outnic_CMDR_0A	; outnic(CMDR, 0x0a) Start, DMA remote read	CALL	innic_Data	;  b = innic(DATAPORT); ;----------------	INCF	rxout,F	; rxout++	BTFSC	STATUS,Z	INCF	rxout+1,F;	MOVF	Param78,W	; check_byte(b);;; Fall through to check_byte_W;=====================================================================================================; Add byte to checksum value; Entry: W=byte to check; Exit: value from W is in Param78 (aka W is unchanged); RAM used: Param78  (verified 10/2/02); Calls: (0) none;check_byte_W	mBank0	MOVWF	Param78; if (checkflag) 	BTFSS	checkflag	GOTO	check_byte_W_1; if ((checklo = b+checklo) < b) 	MOVF	Param78,W	ADDWF	checklo,F	MOVF	Param78,W	SUBWF	checklo,W	BTFSC	STATUS,C	GOTO	check_byte_W_2; if (++checkhi == 0) 	INCFSZ	checkhi,F	GOTO	check_byte_W_2	INCF	checklo,F	; checklo++; else 	GOTO	check_byte_W_2; ; if ((checkhi = b+checkhi) < b) check_byte_W_1	MOVF	Param78,W	ADDWF	checkhi,F	MOVF	Param78,W	SUBWF	checkhi,W	BTFSC	STATUS,C	GOTO	check_byte_W_2; if (++checklo == 0) 	INCFSZ	checklo,F	GOTO	check_byte_W_2	INCF	checkhi,F	; checkhi++; check_byte_W_2	MOVLW	checkflagMask	; checkflag = !checkflag; 	XORWF	CheckFlagFileReg,F	MOVF	Param78,W	;restore W	RETURN;;====================================================================================================; Add remip to checksum value; Entry: none; Exit: none; RAM used: Param78, Param79, Param7A  (verified 1/23/03); Calls: (1+0) check_byte_W;check_remip	MOVLW	remip_b3	GOTO	check_4Data;;====================================================================================================; Add myip to checksum value; Entry: none; Exit: none; RAM used: Param78, Param79, Param7A  (verified 1/23/03); Calls: (1+0) check_byte_W;check_MyIP	MOVLW	myip_b3;;====================================================================================================; Add 4 bytes pointed to by W to checksum value; Entry: W = ptr to first byte to check; Exit: none; RAM used: Param78, Param79, Param7A  (verified 1/23/03); Calls: (1+0) check_byte_W;check_4Data	MOVWF	Param7A	; check_lword(myip) Include addresses in checksum	MOVLW	0x04	MOVWF	Param79;;==========================================================================================; Sends bytes from Param7A to Param7A+Param79-1 to check_byte_W; Entry: Param7A=ptr to data, Param79=length of data; Exit: none; RAM used: Param78, Param79, Param7A, FSR  (verified 1/23/03); Calls:(1+0) check_byte_W;check_data	MOVF	Param7A,W	BCF	_IRP	MOVWF	FSRcheck_data_1	MOVF	INDF,W	CALL	check_byte_W	INCF	FSR,F	DECFSZ	Param79,F	GOTO	check_data_1	RETURN;;====================================================================================================; Gets remip with getch_net; Entry: none; Exit: none; RAM used:  Param71, Param78, Param79, Param7A (verified 1/23/03); Calls:(1+1) getch_net;get_remip	MOVLW	remip_b3	GOTO	get_4Data;;====================================================================================================; Gets rseq with getch_net; Entry: none; Exit: none; RAM used:  Param71, Param78, Param79, Param7A (verified 1/23/03); Calls:(1+1) getch_net;get_rseq	MOVLW	rseq_b3	GOTO	get_4Data;;====================================================================================================; Gets 6 bytes pointed to by W with getch_net; Entry: W pointer to destination; Exit: none; RAM used: Param71, Param78, Param79, Param7A (verified 1/23/03); Calls:(1+1) getch_net;get_6Data	MOVWF	Param7A	MOVLW	0x06	GOTO	get_Ndata;;====================================================================================================; Gets 2 bytes pointed to by W with getch_net; Entry: W pointer to destination; Exit: none; RAM used: Param71, Param78, Param79, Param7A (verified 1/23/03); Calls:(1+1) getch_net;get_2Data	MOVWF	Param7A	MOVLW	0x02	GOTO	get_Ndata;;====================================================================================================; Gets rack with getch_net; Entry: none; Exit: none; RAM used: Param71, Param78, Param79, Param7A (verified 1/23/03); Calls:(1+2) getch_net;get_rack	MOVLW	rack_b3;;====================================================================================================; Gets 4 bytes pointed to by W with getch_net; Entry: W pointer to destination; Exit: none; RAM used: Param71, Param78, Param79, Param7A (verified 1/23/03); Calls:(1+1) getch_net;get_4Data	MOVWF	Param7A	MOVLW	0x04;;=========================================================================; Gets W bytes pointed to by Param7A with getch_net; Entry: Param7A=Dest, W=Bytes to Get; Exit: none; RAM used: Param71, Param78, Param79, Param7A (verified 1/25/03); Calls:(1+1) getch_net;get_Ndata	MOVWF	Param79;;==========================================================================================; gets bytes with getch_net and saves them to Param7A..Param7A+Param79-1; Entry: Param7A=ptr to data, Param79=length of data; Exit: none; RAM used: Param71, Param78, Param79, Param7A, FSR (verified 1/23/03); Calls:(1+1) getch_net;get_data	MOVF	Param7A,W	MOVWF	FSR	BCF	STATUS,IRPget_data_1	CALL	getch_net	MOVWF	INDF	INCF	FSR,F	DECFSZ	Param79,F	GOTO	get_data_1	RETURN;;====================================================================================================; Move bytes from bank 0 or 1 to somewhere else in bank 0 or 1; Entry: Param79=Bytes to move, Param7A=destination, Param7B=Source; Exit: none; RAM used: Param78, Param79, Param7A, Param7B, FSR (verified 1/24/03); Calls:(0) none;MemMove_Low	BCF	STATUS,IRPMemMove_Low_L	MOVF	Param7B,W	MOVWF	FSR	MOVF	INDF,W	MOVWF	Param78	MOVF	Param7A,W	MOVWF	FSR	MOVF	Param78,W	MOVWF	INDF	INCF	Param7A,F	INCF	Param7B,F	DECFSZ	Param79,F	GOTO	MemMove_Low_L	RETURN;;====================================================================================================; Move bytes from bank 0 or 1 to SRAM; Entry: SRAM_Addr=first SRAM byte, Param7A=Bytes to move, FSR=first byte of data in ram; Exit: none; RAM used: Param78, Param7A, FSR (verified 1/25/03); Calls:(1+1) SRAM_WritePI;MemMove_SRAM	BCF	STATUS,IRPMemMove_SRAM_L	MOVF	INDF,W	mCall1To0	SRAM_WritePI	INCF	FSR,F	DECFSZ	Param7A,F	GOTO	MemMove_SRAM_L	RETURN;;====================================================================================================; Move bytes from SRAM to bank 0 or 1; Entry: SRAM_Addr=first SRAM byte, Param7A=Bytes to move, FSR=first dest of data in ram; Exit: none; RAM used: Param7A, FSR (verified 2/4/03); Calls:(1+1) SRAM_ReadPI;MemMoveFrom_SRAM	BCF	STATUS,IRPMemMoveFrom_SRAM_L	mCall1To0	SRAM_ReadPI	MOVWF	INDF	INCF	FSR,F	DECFSZ	Param7A,F	GOTO	MemMoveFrom_SRAM_L	RETURN;;====================================================================================================; Compare bytes from bank 0 or 1 to SRAM, return 0 not matched; Entry: SRAM_Addr=first SRAM byte, Param7A=Bytes to test, FSR=first byte of data in ram; Exit: Param78=(matched=0x01, not matched=0x00); RAM used: Param78, Param7A, FSR (verified 1/24/03); Calls:(1+1) SRAM_ReadPI (1+1);MemComp_SRAM	BCF	STATUS,IRPMemComp_SRAM_L	mCall1To0	SRAM_ReadPI	SUBWF	INDF,W	BTFSS	STATUS,Z	;skip if a match	GOTO	MemComp_Low_Not	INCF	FSR,F	DECFSZ	Param7A,F	GOTO	MemComp_SRAM_L	GOTO	MemComp_Low_found;;====================================================================================================; Compare bytes from bank 0 or 1 to somewhere else in bank 0 or 1, return 0 not matched; Entry: Param79=Bytes to test, Param7A=block 1, Param7B=block 2; Exit: Param78=(matched=0x01, not matched=0x00); RAM used: Param78, Param79, Param7A, Param7B, FSR (verified 1/24/03); Calls:(0) none;MemComp_Low	BCF	STATUS,IRPMemComp_Low_L	MOVF	Param7B,W	MOVWF	FSR	MOVF	INDF,W	MOVWF	Param78	MOVF	Param7A,W	MOVWF	FSR	MOVF	Param78,W	SUBWF	INDF,W	BTFSS	STATUS,Z	;skip if a match	GOTO	MemComp_Low_Not	INCF	Param7A,F	INCF	Param7B,F	DECFSZ	Param79,F	GOTO	MemComp_Low_LMemComp_Low_found	MOVLW	0x01	MOVWF	Param78	RETURNMemComp_Low_Not	CLRF	Param78	RETURN;;====================================================================================================; Match an incoming word value, return Param78=0x01 if matched return 0 not matched, or end of message;; Entry: Param75 high byte (first byte) to match, W low byte (second byte) to match; Exit: Param78=(matched & not atend); RAM used: Param71, Param75, Param78, Param79 (verified 1/23/03); Calls:(1+2) getch_net;match_word	MOVWF	Param79	CALL	match_byteW_2	BTFSS	Param78,0	RETURN	MOVF	Param79,W;;====================================================================================================; Match an incoming byte value, return 0 not matched, or end of message; Entry: W byte to match; Exit: Param78=(matched & not atend); RAM used: Param71, Param75, Param78 (verified 1/23/03); Calls:(1+1) getch_net;match_byteW	MOVWF	Param75match_byteW_2	CALL	getch_net	CLRF	Param78	;assume error	SUBWF	Param75,F	BTFSS	STATUS,Z	RETURN	BTFSC	atend	RETURN	BSF	Param78,0	RETURN;;=========================================================================================; Match an incoming data value to myip, return 0 not matched, or end of message; Entry: none; Exit: Param78=(matched & not atend); RAM used: Param71, Param75, Param78, Param79, Param7A (verified 1/23/03); Calls:(1+2) match_byteW;match_MyIP	MOVLW	myip_b3;;=========================================================================================; Match 4 incoming data bytes to data pointed to by W, return 0 not matched, or end of message; Entry: none; Exit: Param78=(matched & not atend); RAM used: Param71, Param75, Param78, Param79, Param7A (verified 1/23/03); Calls:(1+2) match_byteW;match_4Data	MOVWF	Param7A	MOVLW	0x04	MOVWF	Param79;;fall through to match_data;;==========================================================================================; matches bytes from getch_net to Param7A..Param7A+Param79-1,  return 0 not matched, or end of message; Entry: Param7A=ptr to data, Param79=length of data; Exit: Param78,0 1=match 0=not matched; RAM used: Param71, Param75, Param78, Param79, Param7A, FSR (verified 1/23/03); Calls:(1+2) match_byteW;match_data	MOVF	Param7A,W	MOVWF	FSR	BCF	STATUS,IRP	MOVF	INDF,W	CALL	match_byteW	BTFSS	Param78,0	RETURN	INCF	Param7A,F	DECFSZ	Param79,F	GOTO	match_data	RETURN; ;===================================================================================================; Skip an incoming value, return 0 if end of message; Entry: none; Exit: Param78=atend; RAM used: Param71, Param78 (verified 1/23/03); Calls:(1+1) getch_net;skip_6bytes	CALL	getch_net	CALL	getch_netskip_lword	CALL	getch_net	CALL	getch_netskip_word	CALL	getch_netskip_byte	CALL	getch_net	CLRF	Param78	;assume atend	BTFSS	atend	; return(!atend);	BSF	Param78,0	;OK return(true)	RETURN;;================================================================================================; Put a byte into the network buffer at (txbuff+txin) RAM bank 1; Entry: W = byte to put; Exit: value from W is in Param78 & W (aka W is unchanged); RAM used: Param78, FSR (verified 1/23/03); Calls:(0+0) check_byte_W; putch_net_W	MOVWF	Param78	;save the byte to be put	mBank0; if (txin < TXBUFFLEN) 	MOVLW	TXBUFFLEN	SUBWF	txin,W	BTFSC	STATUS,C	GOTO	putch_net_W_1	MOVF	txin,W	; txbuff[txin++] = b;	INCF	txin,F	ADDLW	txbuff	;0x0A0.. RAM	MOVWF	FSR	BCF	STATUS,IRP	MOVF	Param78,W	MOVWF	INDFputch_net_W_1	MOVF	Param78,W	; check_byte(b); 	GOTO	check_byte_W;;====================================================================================================; Sends rack to putch_net_W; Entry: none; Exit: none; RAM used: Param78, Param79, Param7A, FSR (verified 1/23/03); Calls:(1+0) putch_net_W;put_rack	MOVLW	rack_b3	GOTO	put_4Data;;====================================================================================================; Sends rseq to putch_net_W; Entry: none; Exit: none; RAM used: Param78, Param79, Param7A, FSR (verified 1/23/03); Calls:(1+0) putch_net_W;put_rseq	MOVLW	rseq_b3	GOTO	put_4Data;;====================================================================================================; Sends remip to putch_net_W; Entry: none; Exit: none; RAM used: Param78, Param79, Param7A, FSR (verified 1/23/03); Calls:(1+0) putch_net_W;put_remip	MOVLW	remip_b3	GOTO	put_4Data;;====================================================================================================; Sends myip to putch_net_W; Entry: none; Exit: none; RAM used: Param78, Param79, Param7A, FSR (verified 1/23/03); Calls:(1+0) putch_net_W;put_MyIP	MOVLW	myip_b3;;==========================================================================================; Sends 4 bytes pointed to by W to putch_net_W; Entry: W = ptr; Exit: none; RAM used: Param78, Param79, Param7A, FSR (verified 1/23/03); Calls:(1+0) putch_net_W;put_4Data	MOVWF	Param7A	MOVLW	0x04	MOVWF	Param79;;==========================================================================================; Sends bytes from Param7A to Param7A+Param79-1 to putch_net_W; Entry: Param7A=ptr to data, Param79=length of data; Exit: none; RAM used: Param78, Param79, Param7A, FSR (verified 1/23/03); Calls:(1+0) putch_net_W;put_data	BCF	STATUS,IRP	MOVF	Param7A,W	MOVWF	FSR	MOVF	INDF,W	CALL	putch_net_W	INCF	Param7A,F	DECFSZ	Param79,F	GOTO	put_data	RETURN; ;==========================================================================================; Sends bytes from Param7A to Param7A+Param79-1 to putch_net_W (banks 2 and 3); Entry: Param7A=ptr to data, Param79=length of data; Exit: none; RAM used: Param78, Param79, Param7A, FSR (verified 1/23/03); Calls:(1+0) putch_net_W;put_data2	BSF	STATUS,IRP	MOVF	Param7A,W	MOVWF	FSR	MOVF	INDF,W	CALL	putch_net_W	INCF	Param7A,F	DECFSZ	Param79,F	GOTO	put_data2	RETURN; ;===================================================================================; Put the given data into the NIC's RAM; Entry: Param78=ptr to first byte, Param79=Number of bytes to send; Exit:; RAM used: Param71, Param78, Param79, FSR (verified 1/23/03); Calls:(1+0) outnic_ISR40, outnic_RBCR0_W, outnic_RBCR1_0, outnic_CMDR_W, outnicD78W, innic;putnic_data	MOVF	Param79,W	; Round length up to an even value	ANDLW	0x01		ADDWF	Param79,F;	CALL	outnic_ISR40	;Clear remote DMA interrupt flag	MOVF	Param79,W	CALL	outnic_RBCR0_W	; outnic(RBCR0, len); Byte count	CALL	outnic_RBCR1_0	; outnic(RBCR1, 0);	MOVLW	0x12	; outnic(CMDR, 0x12) Start, DMA remote write	CALL	outnic_CMDR_W; while (len--)  O/P bytes	MOVF	Param78,W	MOVWF	FSR	; 78 is now free	BCF	STATUS,IRP	putnic_data_L1	MOVF	INDF,W	; outnic(DATAPORT, *data++); 	MOVWF	Param78	MOVLW	DATAPORT	CALL	outnicD78W;	INCF	FSR,F	DECFSZ	Param79,F	GOTO	putnic_data_L1;; Count = 255; Done: must ensure DMA complete	MOVLW	0xFF	MOVWF	Param79	;reuse 79 as Count; while (Count && (innic(ISR)&0x40)==0) putnic_data_L2	CALL	innic_ISR	BTFSC	Param78,4	RETURN	DECFSZ	Param79,F	; Count--; 	GOTO	putnic_data_L2	RETURN;;===================================================================================; Put Ethernet packet into buffer given data at txbuff and len Param7D;; Entry: Dest(MAC) nicin.eth.srce, nicin.eth.pcol, Data at txbuff, dlen=txin; Exit: none; RAM used: Param71, Param78, Param79, Param7A, Param7B (verified 1/23/03); Calls:(1+1) outnic_ISR_0A(1+0), setnic_addr(1+1), putnic_data(1+1);;  starting at the beginning (TXSTART) putnic_data:;   Target's MAC address (6 bytes) nicin.eth.srce;   My MAC Address (6 bytes) myeth;   Ethernet proticol (2 bytes) nicin.eth.pcol;   The Data starting at txbuff (Param7D bytes);   put_ether	CALL	outnic_ISR_0A	;Clear interrupt flags	MOVLW	TXSTART	; setnic_addr(TXSTART); 	MOVWF	Param7B		CLRF	Param7A	; low byte	CALL	setnic_addr;	MOVLW	nicin.eth.srce	; putnic_data(nicin.eth.srce, MACLEN); 	MOVWF	Param78	MOVLW	MACLEN	MOVWF	Param79	CALL	putnic_data;	MOVLW	myeth0	; putnic_data(myeth, MACLEN);	MOVWF	Param78	MOVLW	MACLEN	MOVWF	Param79	CALL	putnic_data;	MOVLW	nicin.eth.pcol	; putnic_data(&nicin.eth.pcol, 2); 	MOVWF	Param78	MOVLW	0x02	MOVWF	Param79	CALL	putnic_data;	MOVLW	txbuff	; putnic_data(data, dlen); 	MOVWF	Param78	MOVF	txin,W	MOVWF	Param79	GOTO	putnic_data;;======================================================================================; Transmit the Ethernet frame; Entry:  dlen.l=Param7C, dlen.h=Param7D; Exit:; RAM used: Param71, Param78, Param7C, Param7D (verified 1/23/03); Calls:(1+0) outnicD78W, outnic_CMDR_W;xmit_ether	MOVLW	ETHHDR_LEN	; Add ethernet frame header len to data len	ADDWF	Param7C,F	;  dlen = dlen+MACLEN+MACLEN+2	BTFSC	STATUS,C	;  Dest MAC, Src MAC, pcol	INCF	Param7D,F; if (dlen < MINFRAME) 	MOVF	Param7D,F	BTFSS	STATUS,Z	GOTO	xmit_ether_1	;>=0x100 bytes	MOVLW	MINFRAME	SUBWF	Param7C,W	BTFSC	STATUS,C	GOTO	xmit_ether_1	;>=MINFRAME;	MOVLW	MINFRAME	; dlen = MINFRAME; Constrain length	MOVWF	Param7C;xmit_ether_1	MOVF	Param7C,W	; outnic(TBCR0, dlen.l) Set Tx length regs	MOVWF	Param78	MOVLW	TBCR0	CALL	outnicD78W;										MOVF	Param7D,W	; outnic(TBCR1, dlen.h);	MOVWF	Param78	MOVLW	TBCR1	CALL	outnicD78W	MOVLW	NICTXCMD	; Transmit the packet	GOTO	outnic_CMDR_W;;  ;=====================================================================================;=====================================================================================; Scan the ARP cache for an IP(remip_b0) load into ram if found.; If IP=255 then make it MAC:FF:FF:FF:FF:FF:FF;; Entry: remip_b0=IP of Target; Exit: if Found ARP record is moved into ram;	if pending try again;	copy ar_sha to nicin.eth.srce;       if not found try to find it on network;       ae_state will be pending or resolved;; RAM used: Param70, Param78, Param79, Param7A, Param7B, Param7C, FSR; Calls:(1+4) arp_find(1+3), arp_get(1+2), MemMove_Low (1+0), send_ARP_Req(1+4), arp_add_or_replace(1+4);Locate_ARP	mBank0; Subnet mask is 255.255.255.0 so use the first; three octets of my IP address	MOVLW	0x03	; count	MOVWF	Param79	MOVLW	ar_spa	; dest	MOVWF	Param7A	MOVLW	myip_b3	; source	MOVWF	Param7B	CALL	MemMove_Low	; do the move	MOVF	remip_b0,W	BSF	_RP0	;bank 1	MOVWF	ar_spa+3;; handle broadcast address	BCF	_RP0	;bank 0	SUBLW	0xFF	SKPNZ		;IP Address = 255?	GOTO	Locate_ARP_255	; Yes;	CALL	arp_find;	MOVF	Param78,F	SKPZ	GOTO	Locate_ARP_Gotit	;	BSF	_RP0	;bank 1	CLRF	ae_attempts	BCF	_RP0	;bank 0	GOTO	send_ARP_Req	;not found make first attempt to 			; find it on the network;Locate_ARP_Gotit	CALL	arp_get	;move arp record into ram	BSF	_RP0	;bank 1	MOVLW	AS_PENDING	SUBWF	ae_state,W	;W=ae_state-AS_PENDING	BCF	_RP0	;bank 0	SKPZ		;skip if pending	GOTO	NotPending	;not pending must be resolved;	CALL	send_ARP_Req	; try the network again;; This record must be resolved, we wouldn't have loaded a free one.NotPending	MOVLW	MACLEN	;move the hardware address (MAC)	MOVWF	Param79	; to nicin.eth.srce	MOVLW	ar_sha	MOVWF	Param7B	MOVLW	nicin.eth.srce	MOVWF	Param7A	CALL	MemMove_Low;	BSF	_RP0	;bank 1	if ARPsNeverDie	MOVF	ae_ttl,F	else	DECF	ae_ttl,F	; dec time to live	endif	SKPNZ	CLRF	ae_state	; if TTL is 0x00 mark this record free	CALL	arp_add_or_replaceLocate_ARP_MarkResvd	BSF	_RP0	;bank 1	MOVLW	AS_RESOLVED	; change the ram version of this	MOVWF	ae_state	; record back to resolved	BCF	_RP0	;bank 0	RETURN;Locate_ARP_255	MOVLW	0xFF	MOVWF	nicin.eth.srce	MOVWF	nicin.eth.srce+1	MOVWF	nicin.eth.srce+2	MOVWF	nicin.eth.srce+3	MOVWF	nicin.eth.srce+4	MOVWF	nicin.eth.srce+5	GOTO	Locate_ARP_MarkResvd;;=====================================================================================							 ; Find an free ARP cache record;; Entry: none; Exit: Param78=(0=not found, cache entry #  1..32); RAM used:Param70, Param78, Param79, Param7A, FSR (verified 1/25/03); Calls:(1+1) SRAM_Read, SRAM_OffsetAddr, SRAM_ReadPI; arp_findfree	BSF	Param70,0	;look for a free one	GOTO	arp_find_A	;;=====================================================================================; Find an ARP in the ARP cache;; Entry: ar_spa; Exit: Param78=(0=not found, cache entry #  1..32); RAM used:Param70, Param78, Param79, Param7A, FSR (verified 1/25/03); Calls:(1+1) SRAM_Read(1+1), SRAM_OffsetAddr(1+0), SRAM_ReadPI (1+1); arp_find	BCF	Param70,0	;don't look for a free onearp_find_A	mBank3	MOVLW	high evARPcache	MOVWF	SRAM_Addr2	MOVLW	low evARPcache	MOVWF	SRAM_Addr1	CLRF	SRAM_Addr0	MOVLW	0x01	MOVWF	Param79	;entry 1arp_find_L1	mCall1To0	SRAM_Read	SUBLW	AS_FREE	BTFSC	Param70,0	;looking for a free one	GOTO	arp_find_Free	BTFSC	STATUS,Z	;skip if entry is not free	GOTO	arp_find_next	; it was free;	MOVLW	ar_spa-ae_state	;0x0B	mCall1To0	SRAM_OffsetAddr	;add W to SRAM address	MOVLW	IPAddrLEN	MOVWF	Param7A	;len	MOVLW	ar_spa	; Source Protocol Address	MOVWF	FSR;This would put the 8th address on the stack;	CALL	MemComp_SRAM	;Param78=(1=matched, 0=not); so do it in-line.	CLRF	Param78	;default to not matched	BCF	STATUS,IRParp_find_L2	mCall1To0	SRAM_ReadPI	SUBWF	INDF,W	BTFSS	STATUS,Z	;skip if a match	GOTO	arp_find_noMatch	INCF	FSR,F	DECFSZ	Param7A,F	GOTO	arp_find_L2	MOVLW	0x01	MOVWF	Param78;;fix the SRAM address to point to the beginning of this recordarp_find_noMatch	MOVLW	ARP_TELEN_mask	mBank3	ANDWF	SRAM_Addr0,F	BTFSC	Param78,0	;matched?	GOTO	arp_find_found	;yes;arp_find_next	MOVLW	ARP_TSIZE	SUBWF	Param79,W	;W=Param79-W	BTFSC	STATUS,Z	;last entry?	GOTO	arp_find_not	;yes	INCF	Param79,F	MOVLW	ARP_TELEN	mCall1To0	SRAM_OffsetAddr	;add W to SRAM address	GOTO	arp_find_L1;arp_find_Free	BTFSC	STATUS,Z	;skip if entry is not free	GOTO	arp_find_found	; it was free	GOTO	arp_find_nextarp_find_not	CLRF	Param78	GOTO	arp_find_end;arp_find_found	MOVF	Param79,W	MOVWF	Param78S1_Bank0Rtnarp_find_end	mBank0	RETURN;;====================================================================================;Add this AR address pair to the cache; if this IP is found in the cache then replace the arp record; if this IP is not found then add it to the cache;; Entry: The ARP record (ae_state..ar_spa); Exit: none; RAM used:Param70, Param78, Param79, Param7A, FSR (verified 1/25/03); Calls:(1+2) arp_find(1+2), arp_findfree(1+2) (SRAM_Read, SRAM_OffsetAddr, MemComp_SRAM),;	 MemMove_SRAM (SRAM_WritePI);arp_add_or_replace	CALL	arp_find	MOVF	Param78,W	;0=not found	BTFSC	STATUS,Z	;skip if found;;=====================================================================================; Add a new ARP record to the ARP cache;; Entry: The ARP record (ae_state..ar_spa); Exit: none; RAM used:Param70, Param78, Param79, Param7A, FSR (verified 1/25/03); Calls:(1+2) arp_findfree (1+2),;	 MemMove_SRAM (SRAM_WritePI), arp_Replace; arp_add	CALL	arp_findfree;;missing code: test for cache full & kill oldest;;====================================================================================; Move an ARP record into ram ; Entry: ARP record in ram (ae_state..ar_spa), SRAM_Addr; Exit: none; RAM used: Param78, Param7A, FSR (verified 2/4/03); Calls:(1+2) MemMove_SRAM(SRAM_WritePI);arp_Replace	MOVLW	ARP_TELEN	MOVWF	Param7A	MOVLW	ae_state	MOVWF	FSR	GOTO	MemMove_SRAM;;=====================================================================================; Move an ARP record into ram;; Entry: SRAM_Addr >> start of ARP record; Exit: ARP record in ram ae_state..ar_spa; RAM used: Param7A, FSR (verified 2/4/03); Calls:(1+1) MemMoveFrom_SRAM(SRAM_ReadPI);arp_get	MOVLW	ARP_TELEN	MOVWF	Param7A	MOVLW	ae_state	MOVWF	FSR	GOTO	MemMoveFrom_SRAM;;=====================================================================================; Handle an incoming ARP message;; Entry:; Exit:; RAM used: Param70:0, Param78, Param79, Param7A, Param7D, FSR; Calls:(1+3) match_word(1+2), match_byteW(1+1), skip_6bytes, getch_net, putch_net_W,;	put_ether, xmit_ether;	;; ARP/RARP message format: this all goes into the Data field in the Ethernet Frame (type PCOL_ARP);   Hardware Type (2 bytes) ethernet=1, HTYPE;   Proticol Type (2 bytes) IP type=0x0800, ARPPRO;   Hardware Address Length (HLEN) (1 byte) ethernet=6, MACLEN;   Proticol Addres Length (PLEN) (1 byte) IPv4=4, IPAddrLEN;   Operation (2 bytes) 1 ARPREQ, 2 ARPRESP, 3 RARPREQ, or 4 RARPSESP;   Sender's Hardware Address (MAC);   Sender's IP Address;   Target's Hardware Address (MAC);   Target's IP Address (MAC);; if (match_word(HTYPE) &&    Hardware type = HTYPEarp_recv		if ARPtesting;**************	CLRW	CALL	lcd_GotoLineW_D08	MOVLW	'A'	CALL	DisplaysW_D08;*************	endif;	MOVLW	high HTYPE	MOVWF	Param75	MOVLW	low HTYPE	CALL	match_word	BTFSS	Param78,0	RETURN;; match_word(ARPPRO) &&   ARP protocol = ARPPRO	MOVLW	high ARPPRO	MOVWF	Param75	MOVLW	low ARPPRO	CALL	match_word	BTFSS	Param78,0	RETURN;; Hardware & IP lengths 	MOVLW	MACLEN	; match_byte(MACLEN)	CALL	match_byteW	BTFSS	Param78,0	RETURN;	MOVLW	IPAddrLEN	; match_byte(IPAddrLEN)	CALL	match_byteW	BTFSS	Param78,0	RETURN;; move the next 22 bytes ar_op..ar_tpa	MOVLW	ar_op	MOVWF	Param7A	MOVLW	d'22'	CALL	get_Ndata	BTFSC	atend	; if (!atend) skip	RETURN		; messaage was too short;; Target IP addr (me?) verify that we are the target	MOVLW	0x04	; count	MOVWF	Param79	MOVLW	myip_b3	; block 1	MOVWF	Param7A	MOVLW	ar_tpa	; block 2	MOVWF	Param7B	CALL	MemComp_Low	; do the test	BTFSS	Param78,0	; skip if the IPs match	RETURN;; ok, so what is it?  Operation (2 bytes) 1 ARPREQ or 2 ARPRESP;	if ARPtesting;****************;	mBank1;	MOVF	ar_op,W;	CALL	Disp_Hex_Byte_D08	mBank1	MOVF	ar_op+1,W	CALL	Disp_Hex_Byte_D08;****************	endif;	BSF	STATUS,RP0	; Bank1	MOVF	ar_op,F	BTFSS	STATUS,Z	; skip if high byte = 0	RETURN	MOVLW	low ARPREQ	SUBWF	ar_op+1,W	BTFSC	STATUS,Z	; if (ar_op != ARPREQ) skip	GOTO	HandleARPReq;	MOVLW	low ARPRESP	SUBWF	ar_op+1,W	BTFSC	STATUS,Z	GOTO	HandleARPResp	RETURN		;it's something else;;; move sender's ip address to remipHandleARPReq	MOVLW	0x04	; count	MOVWF	Param79	MOVLW	remip_b3	; dest	MOVWF	Param7A	MOVLW	ar_spa	; source	MOVWF	Param7B	CALL	MemMove_Low	; do the move;	if ARPtesting;****************	MOVLW	'R'	CALL	DisplaysW_D08;****************	endif;;Add this AR address pair to the cache; if this IP is found in the cache then replace the arp record; if this IP is not found then add it to the cache;HandleARPResp	BSF	STATUS,RP0	; Bank1	MOVLW	AS_RESOLVED	MOVWF	ae_state	MOVLW	ATTL_Max	; set time to live at max	MOVWF	ae_ttl	CALL	arp_add_or_replace;;	if ARPtesting;=======================================;; show the arp just received	MOVLW	'P'	CALL	DisplaysW_D08	MOVLW	' '	CALL	DisplaysW_D08; IP	BCF	DispLSpaces	MOVLW	remip_b3	MOVWF	FSR	MOVLW	0x04	MOVWF	Param7DARPTest_L1	MOVF	INDF,W	CALL	Disp_decbyteW_D08	CALL	DisplaysDot_D08	INCF	FSR,F	DECFSZ	Param7D,F	GOTO	ARPTest_L1; MAC	MOVLW	0x01	CALL	lcd_GotoLineW_D08	MOVLW	nicin.eth.srce	;ar_sha	MOVWF	FSR	MOVLW	0x06	MOVWF	Param7DARPTest_L2	MOVF	INDF,W	CALL	Disp_Hex_Byte_D08	INCF	FSR,F	DECFSZ	Param7D,F	GOTO	ARPTest_L2;========================================	endif;; if it was an arp responce we're done	BSF	STATUS,RP0	; Bank1	MOVF	ar_op+1,W	BCF	STATUS,RP0	; Bank0	SUBLW	low ARPRESP	BTFSC	STATUS,Z	RETURN;;;OK, so it's a valid arp req. so build an arp resp to send back.; fall through to send_ARP_Resp;==============================================================================; Sends an ARP responce; Entry:Sender(myeth, myip), Target(nicin.eth.srce, remip); Exit: none; RAM used: Param70:1, Param71, Param78, Param79, Param7A, ;	Param7B, Param7C, Param7D, FSR (verified 1/25/03); Calls:(1+2) putch_net_W(1+0), put_data(1+1), put_MyIP(1+1), put_remip(1+1),;	 Put_ether(1+2)(outnic_ISR_0A(1+0), setnic_addr(1+1), putnic_data(1+1)),;	 xmit_ether(1+0) (outnicD78W, outnic_CMDR_W);send_ARP_Resp	BCF	Param70,1put_ARP_Header	mBank0	CLRF	txin	; txin = 0; ;	MOVLW	high HTYPE	; Hardware type 	CALL	putch_net_W	MOVLW	low HTYPE	CALL	putch_net_W;	MOVLW	high ARPPRO	; ARP protocol	CALL	putch_net_W	MOVLW	low ARPPRO	CALL	putch_net_W;	MOVLW	MACLEN	; Hardware address length	CALL	putch_net_W	MOVLW	IPAddrLEN	; Protocol address length	CALL	putch_net_W;	BTFSC	Param70,1	RETURN;	MOVLW	high ARPRESP	; ARP response 	CALL	putch_net_W	MOVLW	low ARPRESP	CALL	putch_net_W; source MAC (mine)send_ARP_1	MOVLW	myeth0	; put_data(myeth, MACLEN); My MAC addr 	MOVWF	Param7A	;ptr	MOVLW	MACLEN	MOVWF	Param79	;len	CALL	put_data; source IP (mine)	CALL	put_MyIP	; target MAC (where the req. came from)	MOVLW	nicin.eth.srce	; put_data(nicin.eth.srce, MACLEN);   Remote MAC addr 	MOVWF	Param7A	;ptr	MOVLW	MACLEN	MOVWF	Param79	;len	CALL	put_data;; target IP addr (the other guy)	CALL	put_remip;	CALL	put_ether	; put_ether(txbuff, txin); Send to NIC ;	if ARPtesting;**************	MOVLW	0x02	CALL	lcd_GotoLineW_D08	MOVLW	'r'	CALL	DisplaysW_D08; IP	BCF	DispLSpaces	MOVLW	myip_b3	MOVWF	FSR	MOVLW	0x04	MOVWF	Param7DARPTest_L3	MOVF	INDF,W	CALL	Disp_decbyteW_D08	CALL	DisplaysDot_D08	INCF	FSR,F	DECFSZ	Param7D,F	GOTO	ARPTest_L3; MAC	MOVLW	0x03	CALL	lcd_GotoLineW_D08	MOVLW	myeth0	MOVWF	FSR	MOVLW	MACLEN	MOVWF	Param7DARPTest_L4	MOVF	INDF,W	CALL	Disp_Hex_Byte_D08	INCF	FSR,F	DECFSZ	Param7D,F	GOTO	ARPTest_L4;*************	endif;;	MOVF	txin,W	; xmit_ether(txin); Transmit 	MOVWF	Param7C	;len	CLRF	Param7D	;hi byte=0, arp's are small	GOTO	xmit_ether;  ;==============================================================================; Sends an ARP request; Entry:Sender(myeth, myip), Target IP(remip_b0), ae_attempts; Exit: none; RAM used:Param70, Param71, Param78, Param79, Param7A, ;	Param7B, Param7C, Param7D (verified 1/25/03); Calls:(1+3) put_ARP_Header(1+2), putch_net_W(0), MemMove_Low(0), Put_ether(1+2)(outnic_ISR_0A, setnic_addr, putnic_data),;	 xmit_ether(1+0) (outnicD78W, outnic_CMDR_W), arp_add_or_replace (1+3);; ARP/RARP message format: this all goes into the Data field in the Ethernet Frame (type PCOL_ARP);   Hardware Type (2 bytes) ethernet=1, HTYPE;   Proticol Type (2 bytes) IP type=0x0800, ARPPRO;   Hardware Address Length (HLEN) (1 byte) ethernet=6, MACLEN;   Proticol Addres Length (PLEN) (1 byte) IPv4=4, IPAddrLEN;   Operation (2 bytes) 1 ARPREQ, 2 ARPRESP, 3 RARPREQ, or 4 RARPSESP;   Sender's Hardware Address (MAC);   Sender's IP Address;   Target's Hardware Address (MAC);   Target's IP Address (MAC);send_ARP_Req	BSF	Param70,1	;Only load the header	CALL	put_ARP_Header;	MOVLW	high ARPREQ	; put_word(ARPRESP); ARP response 	CALL	putch_net_W	MOVLW	low ARPREQ	CALL	putch_net_W;hardware protocol	MOVLW	high PCOL_ARP	MOVWF	nicin.eth.pcol	MOVLW	low PCOL_ARP	MOVWF	nicin.eth.pcol+1; setup MAC and IP of target	MOVLW	0xFF	;FFFFFFFFFFFF (everyone)	MOVWF	nicin.eth.srce	MOVWF	nicin.eth.srce+1	MOVWF	nicin.eth.srce+2	MOVWF	nicin.eth.srce+3	MOVWF	nicin.eth.srce+4	MOVWF	nicin.eth.srce+5; Subnet mask is 255.255.255.0 so use the first; three octets of my IP address	MOVF	myip_b3,W	MOVWF	remip_b3	MOVF	myip_b2,W	MOVWF	remip_b2	MOVF	myip_b1,W	MOVWF	remip_b1;; Save a pending AR record	BSF	STATUS,RP0	; Bank1	MOVLW	AS_PENDING	MOVWF	ae_state	INCF	ae_attempts,F	CLRF	ae_ttl;	MOVLW	high PCOL_ARP	MOVWF	ar_op	MOVLW	low PCOL_ARP	MOVWF	ar_op+1;	MOVLW	0xFF	MOVWF	ar_sha	MOVWF	ar_sha+1	MOVWF	ar_sha+2	MOVWF	ar_sha+3	MOVWF	ar_sha+4	MOVWF	ar_sha+5;	MOVLW	0x04	; count	MOVWF	Param79	MOVLW	remip_b3	; dest	MOVWF	Param7A	MOVLW	ar_spa	; source	MOVWF	Param7B	CALL	MemMove_Low	; do the move;	CALL	arp_add_or_replace;	GOTO	send_ARP_1	;not bank sensitive;	if UsesUDP;==============================================================================================; Send a UDP datagram given data in txbuff and len txin;; Entry: Data at txbuff, txin=length of data;	locport, remport, nicin.eth.srce, remip; Exit: none; RAM used: Param71, Param7A, Param7B, Param7C, FSR; Calls:(1+2) setnic_addr(0+1)(Param71, Param7A, Param7B), putnic_checkbyte(0+1), put_ip(1+1), put_udp;	tcp_xmit_2(1+2);UDP_Send	mBank0	CLRF	checklo	; checkhi = checklo = 0	CLRF	checkhi	BCF	checkflag	; checkflag = 0	CLRF	tpxdlen	CLRF	tpxdlen+1;hardware protocol	MOVLW	high PCOL_IP	;0x0800	MOVWF	nicin.eth.pcol	MOVLW	low PCOL_IP	MOVWF	nicin.eth.pcol+1;;  O/P data to buffer, calc checksum ;; setnic_addr((TXSTART*256)+ETHERHEADER_LEN+IPHDR_LEN+UDPHDR_LEN)	MOVLW	TXSTART	MOVWF	Param7B	MOVLW	ETHERHEADER_LEN+IPHDR_LEN+UDPHDR_LEN	MOVWF	Param7A	CALL	setnic_addr;;move data to NIC	MOVF	txin,W	; Param7C=len of data at txbuff	MOVWF	Param7C	MOVLW	low txbuff	MOVWF	FSR	BCF	STATUS,IRPUDP_Send_L1	MOVF	INDF,W	CALL	putnic_checkbyte	INCF	FSR,F	DECFSZ	Param7C,F	GOTO	UDP_Send_L1;;=======================================; move checksum to data checksum;; Entry: Data at txbuff, txin=length of data;	locport, remport, nicin.eth.srce, remip; Exit: none; RAM used: Param71, Param7A, Param7B, Param7C, FSR; Calls:(1+2) put_ip(1+1), put_udp, tcp_xmit_2(1+2);UDP_Send_E2	MOVF	checkhi,W	; Save data checksum 	MOVWF	d_checkhi	MOVF	checklo,W	MOVWF	d_checklo;	MOVF	tpxdlen,W	;iplen:=tpxdlen+IPHDR_LEN+UDPHDR_LEN	MOVWF	iplen_b0	MOVF	tpxdlen+1,W	MOVWF	iplen_b1	MOVLW	IPHDR_LEN+UDPHDR_LEN	ADDWF	iplen_b0,F	BTFSC	STATUS,C	INCF	iplen_b1,F; IP header 	MOVLW	PUDP	;d'17'	MOVWF	ipcol;	CALL	put_ip	; IP header	CALL	put_udp	; UDP header ;	if UDPtesting	MOVLW	0x03	CALL	lcd_GotoLineW_D08	MOVLW	'U'	CALL	DisplaysW_D08	MOVLW	'D'	CALL	DisplaysW_D08	MOVLW	'P'	CALL	DisplaysW_D08	MOVLW	' '	CALL	DisplaysW_D08	MOVLW	'T'	CALL	DisplaysW_D08	MOVLW	'x'	CALL	DisplaysW_D08		endif;	GOTO	tcp_xmit_2;;==============================================================================================; Put a UDP header into the buffer (txbuff+txin);; Entry:d_checkhi, d_checklo, locport, remport; Exit:; RAM used:; Calls:(1+1) putch_net_W(0), check_MyIP(1+0), check_remip(1+0), check_byte_W(0), put_ip(1+1);put_udp	mBank0	BCF	checkflag	; checkflag = 0; Ensure we're on an even byte 	MOVF	d_checkhi,W	; checkhi = d_checkhi Retrieve data checksum 	MOVWF	checkhi	MOVF	d_checklo,W	; checklo = d_checklo; 	MOVWF	checklo;Source Port	MOVF	locport_b1,W	CALL	putch_net_W	MOVF	locport_b0,W	CALL	putch_net_W;Dest Port	MOVF	remport_b1,W	CALL	putch_net_W	MOVF	remport_b0,W	CALL	putch_net_W;;Message length (2 bytes) including header (8..1480)	MOVLW	UDPHDR_LEN	; len = tpxdlen + UDPHDR_LEN; 	ADDWF	tpxdlen,W	; len of data in nic ram	MOVWF	Param7C	MOVF	tpxdlen+1,W	BTFSC	STATUS,C	ADDLW	0x01	MOVWF	Param7D	CALL	putch_net_W	MOVF	Param7C,W	CALL	putch_net_W;;;;Checksum the pseudo header Src IP, Dest IP, 0x00 byte, IP protocol, length	CALL	check_MyIP;	CALL	check_remip;	CLRW	CALL	check_byte_W	MOVF	ipcol,W	CALL	check_byte_W;	MOVF	Param7D,W	; check_word(len);	CALL	check_byte_W	MOVF	Param7C,W	CALL	check_byte_W;; Send checksum ; csum includes Data, pseudo header(src IP, Dest IP,0,ipcol,UDP msg len (UDPHDR_LEN+data len)),;  UDP header(Src port, dest port,msg len(UDPHDR_LEN+data len));	COMF	checkhi,W	CALL	putch_net_W;	COMF	checklo,W	GOTO	putch_net_W;;	endif;==============================================================================================; Send out an IP datagram header, given data length; Entry:iplen=total len of datagram; Exit:; RAM used:Param78, Param79, Param7A, FSR (verified 1/23/03); Calls:(1+1) putch_net_W, check_byte_W, check_MyIP, check_remip, put_MyIP, put_remip;put_ip	mBank0	CLRF	txin	; txin = 0; 	CLRF	checklo	; checklo = 0  Clear checksum 	CLRF	checkhi	; checkhi = 0	BCF	checkflag	; checkflag = 0;	MOVLW	0x45	; Version & hdr len	CALL	putch_net_W;	CLRW		; Service=0	CALL	putch_net_W;	MOVF	iplen_b1,W	; iplen	CALL	putch_net_W	MOVF	iplen_b0,W	CALL	putch_net_W;	CLRW		; Ident word=0	CALL	putch_net_W	BSF	STATUS,RP1	;Bank 2	INCF	IPDatagramID,F	; ++id 	MOVF	IPDatagramID,W	CALL	putch_net_W;	CLRW		; Flags & fragment offset 	CALL	putch_net_W	CLRW	CALL	putch_net_W;	MOVLW	0x64	; Time To Live=100	CALL	putch_net_W	MOVF	ipcol,W	; Protocol=ipcol  	CALL	putch_net_W;; check_lword(myip) Include addresses in checksum	CALL	check_MyIP;	CALL	check_remip	; check_lword(remip); ;	COMF	checkhi,W	; Checksum 	CALL	putch_net_W	COMF	checklo,W	CALL	putch_net_W;; myip  Source & destination IP addrs 	CALL	put_MyIP; ; remip	GOTO	put_remip;;=========================================================================================; Put the given byte into the NIC's RAM; Entry: Param78; Exit: Param78 is unchanged; RAM used: Param70, Param78, Param71 (verified 10/2/02); Calls:(1+0) outnic_RBCR0_1, outnic_RBCR1_0, outnic_CMDR_W, outnicD78W;putnic_byte	CALL	outnic_RBCR0_1	; outnic(RBCR0, 1) Byte count	CALL	outnic_RBCR1_0	; outnic(RBCR1, 0); 	MOVLW	0x12	; outnic(CMDR, 0x12);	CALL	outnic_CMDR_W	; Start, DMA remote write	MOVLW	DATAPORT	; outnic(DATAPORT, b); 	GOTO	outnicD78W;;===================================================================================; Put the given byte into the NIC's RAM and add it to checksum; Entry: W; Exit: Value from W is in Param78, tpxdlen++; RAM used: Param78, Param71 (verified 10/2/02); Calls:(1+0) check_byte_W, putnic_byte;putnic_checkbyte	MOVWF	Param78	; check_byte(b); 	CALL	check_byte_W; inline copy of putnic_byte to save a stack word;	CALL	putnic_byte;	CALL	outnic_RBCR0_1	; outnic(RBCR0, 1) Byte count	CALL	outnic_RBCR1_0	; outnic(RBCR1, 0); 	MOVLW	0x12	; outnic(CMDR, 0x12);	CALL	outnic_CMDR_W	; Start, DMA remote write	MOVLW	DATAPORT	; outnic(DATAPORT, b); 	CALL	outnicD78W;	INCF	tpxdlen,F	; tpxdlen++	BTFSC	STATUS,Z	INCF	tpxdlen+1,F	RETLW	00;;================================================================================================; Converts a byte value to a string; output to putnic_checkbyte is '000'..'255'; Entry: W = byte  '000'..'255'; Exit: none; RAM used: Param71:0, Param77, Param78, Param79; Calls:(1+3) Disp_decbyteW, putnic_checkbyte;Dec_Put_n_Check	mBank0	BSF	NumsToNic	mCall1To0	Disp_decbyteW	BCF	NumsToNic	RETURN;;===============================================================================================; 16 bit version of Dec_Put_n_Check; output to putnic_checkbyte is '00000'..'65535'; Enrty: Param77:Param76  16 bit value; Exit: none; RAM used: Param76, Param77, Param78, Param79, Param7A; Calls: (1+3) Disp_decword, putnic_checkbyte;DecWPut_n_Check	mBank0	BSF	NumsToNic	mCall1To0	Disp_decword	BCF	NumsToNic	RETURN;	if Uses3BNums;===============================================================================================; 24 bit version of Disp_decbyteW; output to DisplaysW is '00000000'..'16777215'; Enrty: Param77:Param76:Param74  24 bit value little endian; Exit: none; RAM used: Param74,Param76, Param77, Param78, Param79, Param7A, Param7B; Calls: (1+3) Disp_dec3B, putnic_checkbyte;Dec3BPut_n_Check	mBank0	BSF	NumsToNic	mCall1To0	Disp_dec3B	BCF	NumsToNic	RETURN;	endif;===============================================================================================; Copy a block from NIC Rx to Tx buffers (not crossing page boundaries); Entry: Param79=dest, Param7A=srce, Param7B=len; Exit: none; RAM used: Param79, Param7A, Param7B; Calls: (1+1) outnic_ISR40, outnic_RSPR0_W, outnic_RSPR1_W, getnic_byte,;	outnic_RSPR0_W, outnic_RSPR1_W, putnic_byte;copy_rx_tx	CALL	outnic_ISR40	; outnic(ISR, 0x40) Clear remote DMA interrupt flag	MOVLW	ETHERHEADER_LEN	; dest += sizeof(ETHERHEADER);	ADDWF	Param79,F	MOVLW	NICETHERHEADER_LEN	; srce += sizeof(NICETHERHEADER);	ADDWF	Param7A,F; while (len--) copy_rx_tx_L1	MOVF	Param7A,W	; outnic(RSAR0, srce);	CALL	outnic_RSPR0_W	MOVF	curr_rx_page,W	; outnic(RSAR1, curr_rx_page); 	CALL	outnic_RSPR1_W	CALL	getnic_byte	; b = getnic_byte();;	MOVF	Param79,W	; outnic(RSAR0, dest); 	CALL	outnic_RSPR0_W	MOVLW	TXSTART	; outnic(RSAR1, TXSTART); 	CALL	outnic_RSPR1_W	CALL	putnic_byte	;Param78;	INCF	Param7A,F	; srce++;	INCF	Param79,F	; dest++;	DECFSZ	Param7B,F	; len--	GOTO	copy_rx_tx_L1	RETURN		; we're done;;========================================================================================	; Checksum the given number of bytes in the Rx NIC buffer;; Entry: Param76=len.l, Param77=len.h; Exit: checklo, checkhi are updated; RAM used: Param71, Param76, Param77, Param78 (verified 1/30/03); Calls:(1+0) outnic_ISR40, outnic_RBCR0_W, outnic_RBCR1_W, outnic_CMDR_0A, innic, check_byte_W; 		check_rxbytes	CALL	outnic_ISR40	; outnic(ISR, 0x40) Clear remote DMA interrupt flag	MOVF	Param76,W	CALL	outnic_RBCR0_W	; outnic(RBCR0, len); Byte count;	MOVF	Param77,W	; outnic(RBCR1, len>>8); 	CALL	outnic_RBCR1_W	CALL	outnic_CMDR_0A	; outnic(CMDR, 0x0a) Start, DMA remote read; repeat Get bytes check_rxbytes_L1	CALL	innic_Data	; W = innic(DATAPORT)	CALL	check_byte_W	; check_byte(W);;	DECFSZ	Param76,F	;len:=len-1	GOTO	check_rxbytes_L1	MOVF	Param77,W	BTFSC	STATUS,Z	RETURN		;until len=0	DECF	Param77,F	GOTO	check_rxbytes_L1;;=======================================================================================; Inrement rseq;IncRSeq	INCFSZ	rseq_b0,F	; rseq=rseq+1   Adjust Tx ack for SYN 	GOTO	IncRSeq_end	INCFSZ	rseq_b1,F	GOTO	IncRSeq_end	INCFSZ	rseq_b2,F	GOTO	IncRSeq_end	INCF	rseq_b3,FIncRSeq_end	RETURN; ;=======================================================================================; Get an IP datagram;; Entry: data in NIC buffer, Bank0; Exit:; RAM used:; Calls:(1+4) match_byteW, getch_net, skip_word, skip_byte,;	tcp_recv, tcp_handler; ip_recv	BCF	checkflag	; checkflag = 0 Clear checksum 	CLRF	checklo	; checklo = 0 	CLRF	checkhi	; checkhi = 0;	MOVLW	0x45	; Version	CALL	match_byteW;	CALL	skip_byte	;Servive Type;	CALL	getch_net	;length of datagram	MOVWF	iplen_b1	CALL	getch_net	MOVWF	iplen_b0;	CALL	skip_lword	;datagram ID, Frags, Fragment offset;	CALL	skip_byte	;Time to live;	CALL	getch_net	;Protocol	MOVWF	ipcol;	CALL	skip_word	;checksum ;	CALL	get_remip	;source IP address	BTFSC	atend	RETURN		;Data Too Short!;	if AllowReceiveBroadcast;destination IP address is me or my subnet.255	MOVLW	myip_b3	MOVWF	Param7A	MOVLW	0x03	MOVWF	Param79	CALL	match_data	BTFSS	Param78,0	;Matched?	RETURN		; No	CALL	getch_net	SUBWF	myip_b0,W	SKPNZ		;This packet is for me?	GOTO	ip_recv_1	; Yes	INCFSZ	Param78,W	;Broadcast addr 255?	RETURN		; No;ip_recv_1	else;destination IP address is me	CALL	match_MyIP	BTFSS	Param78,0	RETURN	endif;; if checkhi=0xff and checklo=0xff then Checksum is OK 	INCF	checkhi,W	SKPZ	RETURN;	INCF	checklo,W	SKPZ	RETURN;;OK, It seems to be a valid IP proticol, but which one?	if UsesUDP; if (ipcol == PUDP)	MOVLW	PUDP	; User Datagram Protocol? 	SUBWF	ipcol,W	SKPNZ	GOTO	UDP_recv	; goto UDP handler	endif;; if (ipcol == PICMP)	MOVLW	PICMP	; ICMP? 	SUBWF	ipcol,W	SKPNZ	GOTO	icmp_recv	; goto ping handler 	;	MOVLW	PTCP	; else if (ipcol == PTCP)   TCP segment? 	SUBWF	ipcol,W	SKPZ	RETURN		;I don't know this pcol, dump it.;; fall through to tcp_recv;;;;======================================================================================================; Test a TCP segment to see if it is valid; Entry: NIC buffer pointer points to first byte of TCP Header; Exit: NIC buffer pointer points to first byte of TCP Data;       if this is a Valid TCP segment then we fall through to tcp_handler; RAM used: Param76, Param77, Param78, Param79, Param7A, Param7B; Calls:(1+2++) getch_net, skip_6bytes, check_byte_W, getnic_addr, setnic_addr;;tcp_recv	CLRF	checklo	; checkhi = checklo = 0; 	CLRF	checkhi;	CALL	getch_net	;Source Port	MOVWF	remport_b1	CALL	getch_net	MOVWF	remport_b0;	CALL	getch_net	;Destination Port	MOVWF	locport_b1	CALL	getch_net	MOVWF	locport_b0;	CALL	get_rseq	;Sequence Number;	CALL	get_rack	;Acknowledge number	BTFSC	atend	RETURN;	CALL	getch_net	MOVWF	Param77	;header len (upper 4 bits only)	RRF	Param77,F	; make hlen into header length	RRF	Param77,F	; in bytes not long words	MOVLW	0x3C	; don't overrun the buffer	ANDWF	Param77,F	; 0x00,0x04..0x3C	BTFSC	atend	RETURN;	CALL	getch_net	;flags	MOVWF	rflags	;lower 6 bits	BTFSC	atend	RETURN;; skip:  Window, csum, urgent ptr 	CALL	skip_6bytes	BTFSC	atend	RETURN;; Check the pseudo header AND the data then restore the NIC buffer ptr to the;  beginning of the Data field.	BCF	Param70,0	;use CheckPseudo inline;===============================================================================; Check the pseudo header.;; Entry: Param70,0=1; Exit: Param7B:Param7A address to the params used by setnic_addr; RAM used:; Calls:(1+1) check_MyIP(1+0), check_remip, check_byte_W, getnic_addr;; iplen = iplen-IPHDR_LEN; Get TCP segment length CheckPseudo	MOVLW	IPHDR_LEN	SUBWF	iplen_b0,F	BTFSS	STATUS,C	DECF	iplen_b1,F;;Include the pseudo header in the csum (8 bytes); Source IP Address, Dest IP Address, 0x00 byte, ipcol byte, message length word;; check_lword(myip.l)	CALL	check_MyIP; check_lword(remip.l)	CALL	check_remip;	CLRW		; check_byte(0)	CALL	check_byte_W;	MOVF	ipcol,W	; check_byte(ipcol)	CALL	check_byte_W;	MOVF	iplen_b1,W	; check_word(iplen)	CALL	check_byte_W	MOVF	iplen_b0,W	CALL	check_byte_W;end of pseudo header;; rxout = hlen + IPHDR_LEN; Skip over options if any	MOVLW	IPHDR_LEN	ADDWF	Param77,W	MOVWF	rxout	CLRF	rxout+1; rpdlen = iplen - rxout + IPHDR_LEN;		MOVF	iplen_b0,W	MOVWF	rpdlen_b0	MOVF	iplen_b1,W	MOVWF	rpdlen_b1	MOVF	rxout,W	SUBWF	rpdlen_b0,F	BTFSS	STATUS,C	DECF	rpdlen_b1,F	MOVLW	IPHDR_LEN	ADDWF	rpdlen_b0,F	BTFSC	STATUS,C	INCF	rpdlen_b1,F; addr = getnic_addr()  Save the current location (start of data)	CALL	getnic_addr	MOVF	Param79,W	;move address to the params	MOVWF	Param7B	;used by setnic_addr.	MOVF	Param78,W	MOVWF	Param7A;	BTFSC	Param70,0	RETURN		;CheckPseudo was called so return;; check the rest of the bytes in the datagram, but leave them in the rx buffer; check_rxbytes(iplen-TCPHDR_LEN);  77:76=byte count	MOVF	iplen_b0,W	;iplen	MOVWF	Param76	MOVLW	TCPHDR_LEN	SUBWF	Param76,F	MOVF	iplen_b1,W	MOVWF	Param77	BTFSS	STATUS,C	DECF	Param77,F	CALL	check_rxbytes;; restore ptr so next byte we get is the first data byte; setnic_addr(addr) 	CALL	setnic_addr;; if (checkhi=0xff) and (checklo=0xff) then this data is a valid TCP segment	INCF	checkhi,W	SKPZ	RETURN		;bad csum	INCF	checklo,W	SKPZ	RETURN		;bad scum;;this is a valid TCP segment so go handle it;;;;====================================================================================================; Handle an incoming TCP segment;  RST bit is set: Do nothing;  SYN bit is set: rseq++;     if it is a valid port then send SYN,ACK  our SYN number is concount<<16;       else send ACK,RST;  FIN bit is set: send ACK  rseq=rseq+1+rpdlen;  ACK bit not set: send ACK;  ACK bit is set: send data FIN and ACK; Entry: A valid TCP segment is in the NIC's ram; Exit: ; RAM used:; Calls:(1+2+) Add_rseq_rpdlen, IncRSeq, tcp_xmit;  May branch to http_recv, daytime_handler, DataPort_handler or TFTPPort_handler.;;tcp_handler	CLRF	tpxdlen+1	; tpxdlen = 0;  Assume no Tx data	CLRF	tpxdlen	CLRF	d_checklo	; Set data csum to zero.	CLRF	d_checkhi	;  If ACK only no data is sent.	BCF	checkflag	; checkflag = 0;;plan on sending an acknowledgement	MOVLW	TACK	; tflags = TACK  ..and just sending an ack 	MOVWF	tflags	;;; if (rflags & TRST) RESET received? 	MOVF	rflags,W	ANDLW	TRST	BTFSS	STATUS,Z	RETURN		;Resets are ignored;; if (rflags & TSYN) SYN received? 	MOVF	rflags,W	ANDLW	TSYN	BTFSC	STATUS,Z	GOTO	tcp_handler_TFIN;;TSYN recieved: Synchronize sequence numbers	CALL	IncRSeq;;*** check to see if this segment is for one of our ports ***;; if (locport=DAYPORT) goto tcp_handler_GoodPort	MOVF	locport_b1,F	BTFSS	STATUS,Z	GOTO	tcp_handler_BadPort	MOVLW	low DAYPORT	SUBWF	locport_b0,W	BTFSC	STATUS,Z	GOTO	tcp_handler_GoodPort;; if (locport=HTTPORT) goto tcp_handler_GoodPort	MOVLW	low HTTPORT	SUBWF	locport_b0,W	BTFSC	STATUS,Z	GOTO	tcp_handler_GoodPort;;if (locport=IPDATAPORT) goto tcp_handler_GoodPort	MOVLW	low IPDATAPORT	SUBWF	locport_b0,W	BTFSC	STATUS,Z	GOTO	tcp_handler_GoodPort;;if (locport=TTFTPtoEEROMPort) goto tcp_handler_GoodPort		if TTFTPtoEEROM	MOVLW	low TTFTPtoEEROMPort	SUBWF	locport_b0,W	BTFSC	STATUS,Z	GOTO	tcp_handler_GoodPort	endif;;if (locport=TTFTPtoEEROMPort) goto tcp_handler_GoodPort		if TTFTPtoSRAM	MOVLW	low TTFTPtoSRAMPort	SUBWF	locport_b0,W	BTFSC	STATUS,Z	GOTO	tcp_handler_GoodPort	endif;	if UsesRS232BufIO	MOVLW	low TCPRS232Port	SUBWF	locport_b0,W	BTFSC	STATUS,Z	GOTO	tcp_handler_GoodPort	endif;	GOTO	tcp_handler_BadPort	; Unrecognised port;; Recognised porttcp_handler_GoodPort	MOVLW	0xFF	MOVWF	rack_b1	; rack.w[0] = 0xffff; 	MOVWF	rack_b0	MOVF	concount_b1,W	; rack.w[1] = concount++; 	MOVWF	rack_b3	MOVF	concount_b0,W	MOVWF	rack_b2	INCF	concount_b0,F	BTFSC	STATUS,Z	INCF	concount_b1,F	MOVLW	TSYN+TACK	; tflags=TSYN+TACK  Send SYN ACK tcp_handler_Ret	MOVWF	tflags	GOTO	tcp_xmit	; ..do it ; ; Unrecognised porttcp_handler_BadPort	MOVLW	TRST+TACK	; tflags=TRST+TACK  Send reset 	GOTO	tcp_handler_Ret; ; if (rflags & TFIN)  Received FIN? tcp_handler_TFIN	MOVF	rflags,W	ANDLW	TFIN	BTFSC	STATUS,Z	GOTO	tcp_handler_TACK;Received FIN rseq=rseq+1    Ack all incoming data + FIN 	CALL	IncRSeq;	CALL	Add_rseq_rpdlen	GOTO	tcp_xmit;;Add_rseq_rpdlen	MOVF	rpdlen_b1,W	;rseq=rseq+rpdlen	ADDWF	rseq_b1,F	; add the high byte	MOVLW	0x01	BTFSC	STATUS,C	ADDWF	rseq_b2,F	; carry was set	BTFSC	STATUS,C	ADDWF	rseq_b3,F	; carry was set again;	MOVF	rpdlen_b0,W	ADDWF	rseq_b0,F	MOVLW	0x01	BTFSC	STATUS,C	ADDWF	rseq_b1,F	BTFSC	STATUS,C	ADDWF	rseq_b2,F	BTFSC	STATUS,C	ADDWF	rseq_b3,F	RETURN;; if (rflags & TACK)  ACK received? tcp_handler_TACK	MOVF	rflags,W	ANDLW	TACK	BTFSC	STATUS,Z	GOTO	tcp_xmit	;ack bit was not set; ; if (rpdlen)  Adjust Tx ack for Rx data 	MOVF	rpdlen_b0,W	IORWF	rpdlen_b1,W	SKPZ;;Data came in so it must be acknowledged	CALL	Add_rseq_rpdlen	; rseq=rseq+rpdlen;; if (locport=HTTPORT and rpdlen<>0) then goto the http handler	CLRF	Param78	;0	MOVF	locport_b1,F	BTFSS	STATUS,Z	RETURN		;all of our ports	MOVLW	HTTPORT	; start with 0x00	SUBWF	locport_b0,W	BTFSC	STATUS,Z	GOTO	tcp_PortDispatch;; if (locport=DAYPORT and rack.w[0]=0) then goto then daytime handler	MOVLW	0x02	MOVWF	Param78	;2	MOVLW	DAYPORT	SUBWF	locport_b0,W	BTFSC	STATUS,Z	GOTO	tcp_PortDispatch;	if UsesTCPIPDataPort; if (locport=IPDATAPORT and rpdlen<>0) then goto DataPort handler 	INCF	Param78,F	;3	MOVLW	low IPDATAPORT	SUBWF	locport_b0,W	BTFSC	STATUS,Z	GOTO	tcp_PortDispatch	endif;	MOVLW	0x05	MOVWF	Param78	;5	if TTFTPtoEEROM	MOVLW	low TTFTPtoEEROMPort	SUBWF	locport_b0,W	BTFSC	STATUS,Z	GOTO	tcp_PortDispatch	endif;		INCF	Param78,F	;6	if TTFTPtoSRAM	MOVLW	low TTFTPtoSRAMPort	SUBWF	locport_b0,W	BTFSC	STATUS,Z	GOTO	tcp_PortDispatch	endif;	INCF	Param78,F	;7	if UsesRS232BufIO	MOVLW	low TCPRS232Port	SUBWF	locport_b0,W	BTFSC	STATUS,Z	GOTO	tcp_PortDispatch	endif	INCF	Param78,F	;8 not used	INCF	Param78,F	;9;Not a valid port	RETURN		;no more ports;;-------------------------------------;tcp_PortDispatch	MOVF	rpdlen_b0,W	;there must be some data	IORWF	rpdlen_b1,W	BTFSC	STATUS,Z	;Data length = 0?	RETURN		; Yes	MOVF	Param78,W	mPCLGoto	BSF	PCLATH,4	;0	GOTO	http_recv	;  not used	GOTO	daytime_handler	;2;	if UsesTCPIPDataPort	BSF	PCLATH,4	;3	GOTO	DataPort_handler	;  not used	else	NOP	RETURN		;changed from nop 4/13/04	endif;	if TTFTPtoEEROM	GOTO	TFTPPortE_handler	;5	else	RETURN	endif;	if TTFTPtoSRAM	GOTO	TFTPPortS_handler	;6	else	RETURN	endif;	if UsesRS232BufIO	BSF	PCLATH,4	;7, it's in segment 3	GOTO	RS232Port_handler	;  not used	else	NOP	RETURN	endif;;========================================================================================; Respond to an Daytime request   Prepare daytime data ; The DayPort port 13 is used to set and read the clock.;; Entry:; Exit:; RAM used: Param71, Param78, Param79, Param7A, Param7B, Param7D, Param7F, FSR (verified 1/30/03); Calls:(1+3) getch_net, setnic_addr, putnic_checkbyte(1+0), PutString(1+2); daytime_handler	CLRF	Param79	;i=0;;buffer the command in romdir.f.namedaytime_handler_L2	CALL	getch_net	;send one char to disp	BTFSC	atend	GOTO	daytime_handler_2	;atend	MOVLW	low romdir.f.name	ADDWF	Param79,W	;i	MOVWF	FSR	BSF	STATUS,IRP	MOVF	Param78,W	MOVWF	INDF	;romdir.f.name+Param79	INCF	Param79,F	MOVLW	ROM_FNAMELEN	SUBWF	Param79,W	BTFSS	STATUS,Z	;12 chars max	GOTO	daytime_handler_L2	;daytime_handler_2	CALL	Std_TCP_Setup;	MOVLW	low romdir.f.name	MOVWF	FSR	BSF	STATUS,IRP	MOVLW	'='	; one letter command to set time?	SUBWF	INDF,W	BTFSS	STATUS,Z	GOTO	daytime_Read;daytime_Write		if HasRTC	BSF	STATUS,RP1	MOVF	romdir.f.name+1,W	MOVWF	RTC_Year	MOVF	romdir.f.name+2,W	MOVWF	RTC_Month	MOVF	romdir.f.name+3,W	MOVWF	RTC_Day	MOVF	romdir.f.name+4,W	MOVWF	RTC_Hours	MOVF	romdir.f.name+5,W	MOVWF	RTC_Minutes	MOVF	romdir.f.name+6,W	MOVWF	RTC_Seconds		mCall1To0	set_rtc	endif;daytime_Read	if HasRTC;	mCall1To0	read_rtc	CLRF	Param7D	;Countdaytime_handler_L1	MOVLW	low RTC_Year	ADDWF	Param7D,W	MOVWF	FSR	BSF	STATUS,IRP	MOVF	INDF,W	CALL	putnic_checkbyte	MOVLW	0x05	;send 6 bytes	SUBWF	Param7D,W	BTFSC	STATUS,Z	GOTO	daytime_handler_1	INCF	Param7D,F	GOTO	daytime_handler_L1;daytime_handler_1		else;	MOVLW	Str_DAYMSGPtr	;"No daytime msg\r\n"	CALL	PutString;	endif;	MOVLW	TFIN+TACK	; tflags = TFIN+TACK  Ack & close connection Do_TCP_Wflags	MOVWF	tflags	MOVF	checkhi,W	; d_checkhi = checkhi   Save checksum 	MOVWF	d_checkhi	MOVF	checklo,W	; d_checklo = checklo	MOVWF	d_checklo;	GOTO	tcp_xmit	; ..do it ;;=====================================================================================================; Clear checksum, setnic_addr((TXSTART*256)+ETHERHEADER_LEN+IPHDR_LEN+TCPHDR_LEN);; Entry: none; Exit: none; RAM used: Param71, Param7A, Param7B (verified 1/23/03); Calls:(0+1) setnic_addr(1+0);Std_TCP_Setup	mBank0	CLRF	checklo	;checkhi = checklo = 0; 	CLRF	checkhi	BCF	checkflag	; checkflag = 0; ;; setnic_addr((TXSTART*256)+ETHERHEADER_LEN+IPHDR_LEN+TCPHDR_LEN)	MOVLW	TXSTART	MOVWF	Param7B	MOVLW	ETHERHEADER_LEN+IPHDR_LEN+TCPHDR_LEN	MOVWF	Param7A	GOTO	setnic_addr;;;=========================================================================================; Send string number (W) to IP frame buffer; Param7D=CharCount, Param7F=StringNumber; (putnic_checkbyte:Param78, Param71);; Entry: W = string number; Exit: none; RAM used: Param71, Param78, Param7D, Param7F (verified 1/30/03); Calls:(1+2) putnic_checkbyte,StringDispatch;PutString	MOVWF	Param7F	CLRF	Param7D	;CharCount=0PutString_L1		if CodeMemStrings	mCall1To2	StringDispatch	;Get the next Char	endif	if SRAM_Strings	mCall1To0	StringDispatch	;Get the next Char	endif	INCF	Param7D,F	;CharCount:=CharCount+1	IORLW	0x00	;set Z if last char	BTFSC	STATUS,Z	RETURN		;00 = done	CALL	putnic_checkbyte	;Put the Char	GOTO	PutString_L1;;	if TTFTPtoSRAM;;========================================================================================; Handler for the TFTP Port SRAM version;  if length is zero then send 256 bytes from SRAM starting at Address and ACK;  if length is greater than zero (1..1024) then write this data to SRAM and ;    send length bytes from SRAM starting at Address and ACK.;  if the MSb of the length is set then send 1..1024 bytes from SRAM starting at Address and ACK.;; Entry:next NIC byte to read is first byte of TCP segment's data field; Exit: tcp_xmit; RAM used: Param71, Param78, Param79, Param7A, Param7B, Param7C, Param7D, FSR (verified 4/29/04); Calls:(1+2) getch_net, SRAM_WritePI, TFTPPortS_ReadAll, TFTPPortS_Read;TFTPPortS_handler	MOVLW	low SRAM_Len	MOVWF	FSR	BSF	_IRP	MOVLW	0x05	;move 5 bytes	MOVWF	Param79;TFTPPortS_handler_L2	CALL	getch_net	; get SRAM_Len..SRAM_DestAddr0	MOVWF	INDF	INCF	FSR,F	DECFSZ	Param79,F	GOTO	TFTPPortS_handler_L2;	BTFSC	atend	RETURN		; bad data, too short;; If length of data is 0x00 goto TFTPPortS_ReadAll and read 256 bytes.	mBank3	MOVFW	SRAM_Len	IORWF	SRAM_Len_Lo,W	SKPNZ	GOTO	TFTPPortS_ReadAll;; If SRAM_Len,7 is set then go copy the data from SRAM to the NICs buffer	BTFSS	SRAM_Len,7	;Is the read only flag set?	GOTO	TFTPPortS_handler_1	; No	MOVLW	0x07	ANDWF	SRAM_Len,F	GOTO	TFTPPortS_Read;; Move SRAM_Len bytes of data into SRAMTFTPPortS_handler_1	MOVF	SRAM_Len,W	ANDLW	0x07	;Len 0x0001..0x0400			; the MSb is the read only flag.	MOVWF	Param7A	MOVF	SRAM_Len_Lo,W	MOVWF	Param79	MOVF	SRAM_DestAddr2,W	MOVWF	SRAM_Addr2	MOVF	SRAM_DestAddr1,W	MOVWF	SRAM_Addr1	MOVF	SRAM_DestAddr0,W	MOVWF	SRAM_Addr0;TFTPPortS_handler_L1	CALL	getch_net	; get the next data byte	BTFSC	atend	RETURN		; bad data, too short	mCall1To0	SRAM_WritePI;	MOVLW	0x01	SUBWF	Param79,F	SUBBF	Param7A,F	MOVF	Param79,W	IORWF	Param7A,W	SKPZ	GOTO	TFTPPortS_handler_L1	GOTO	TFTPPortS_Read;;========================================================================================================; Read 256 bytes from SRAM into NIC buffer and send it (tflags  Ack & close & Push);; Entry: SRAM_DestAddr; Exit: tcp_xmit; RAM used: Param71, Param78, Param79, Param7A, Param7B, Param7C, Param7D, FSR (verified 4/29/04); Calls:(1+2) TFTPPortS_Read;TFTPPortS_ReadAll	mBank3	MOVLW	0x01	MOVWF	SRAM_Len	;make len=0x0100	CLRF	SRAM_Len_Lo;; fall through to TFTPPortS_Read;;=========================================================================================================; Read SRAM_Len bytes from the SRAM into the nic buffer and send it (tflags  Ack & close & Push);; Entry: SRAM_Len, SRAM_DestAddr; Exit: tcp_xmit; RAM used: Param71, Param78, Param79, Param7A, Param7B, Param7C, Param7D, FSR (verified 4/29/04); Calls:(1+2) setnic_addr, putnic_checkbyte, SRAM_ReadPI, tcp_xmit;; Send data to nic buffer, calc checksum ; 1069 bytes max (IPHDR_LEN+TCPHDR_LEN+lenWord+Address+1024 Data);TFTPPortS_Read	CALL	Std_TCP_Setup	MOVLW	IPHDR_LEN+TCPHDR_LEN	;txin = IPHDR_LEN + TCPHDR_LEN	MOVWF	txin;;Move length and address (5 bytes) to NIC buffer	MOVLW	low SRAM_Len	MOVWF	FSR	BSF	_IRP	MOVLW	0x05	MOVWF	Param79TFTPPortS_Read_L1	MOVF	INDF,W	CALL	putnic_checkbyte	INCF	FSR,F	DECFSZ	Param79,F	GOTO	TFTPPortS_Read_L1;	mBank3	MOVF	SRAM_Len,W	MOVWF	Param7A	MOVF	SRAM_Len_Lo,W	MOVWF	Param79	MOVF	SRAM_DestAddr2,W	MOVWF	SRAM_Addr2	MOVF	SRAM_DestAddr1,W	MOVWF	SRAM_Addr1	MOVF	SRAM_DestAddr0,W	MOVWF	SRAM_Addr0;	TFTPPortS_Read_L2	mCall1To0	SRAM_ReadPI	CALL	putnic_checkbyte;	MOVLW	0x01	SUBWF	Param79,F	SUBBF	Param7A,F	MOVF	Param79,W	IORWF	Param7A,W	SKPZ	GOTO	TFTPPortS_Read_L2;TFTPPortS_Read_1	MOVLW	TFIN+TACK+TPUSH	; tflags  Ack & close & Push	GOTO	Do_TCP_Wflags	; ..do it;	endif;	if TTFTPtoEEROM;========================================================================================; Handler for the TFTP Port, EEROM version.;  This handler moves data in and out of the eeROM via port 69 "TFTPPort" Trivial FTP.;  if length is zero then send 32 bytes from eeROM starting at Address and ACK;  if length is greater than zero (1..32) then write this data to eeROM and ;    send length bytes from eeROM starting at Address and ACK;  TFTP data len is limited to the serial eeprom write buffer limit of 32 bytes;    WriteEEROM could be modified to handle multipul write cycles;  if EnableEEROMCopy=1 then eeROMbuff.len,7 causes CopyEEROMtoSRAM to be called with;   the lower 4 bits of eeROMbuff.len as the bank number.;  if EnableEEROMCopy=1 then eeROMbuff.len,6 causes EraseEEROM to be called.;; Entry:next NIC byte to read is first byte of TCP segment's data field; Exit:; RAM used:Param79, Param7A, Param7C FSR; Calls:(1+2) getch_net(1+0), WriteEEROM(1+1), DelayWmS_D08(1+0+0), ReadEEROM, setnic_addr, putnic_checkbyte;TFTPPortE_handler	MOVLW	low eeROMbuff.len	MOVWF	FSR	mBankISel	eeROMbuff.len	MOVLW	0x04	MOVWF	Param79	;bytes to move;TFTPPortE_handler_L2	CALL	getch_net	; get the len	MOVWF	INDF	INCF	FSR,F	DECFSZ	Param79,F	GOTO	TFTPPortE_handler_L2;	BTFSC	atend	RETURN		; bad data, too short;; if length of data is 0x00 goto TFTPPortE_ReadAll;	mBank2	MOVFW	eeROMbuff.len	MOVWF	Param7C	SKPNZ	GOTO	TFTPPortE_ReadAll;; tx EEROM to SRAM?	if EnableEEROMCopy	MOVLW	0xC0	ANDWF	eeROMbuff.len,W	SKPNZ	GOTO	TFTPPortE_handler_1	CALL	Std_TCP_Setup	MOVLW	IPHDR_LEN+TCPHDR_LEN	;txin = IPHDR_LEN + TCPHDR_LEN	MOVWF	txin;	MOVLW	'O'	CALL	putnic_checkbyte	MOVLW	'K'	CALL	putnic_checkbyte;	MOVLW	TFIN+TACK+TPUSH	; tflags = TFIN+TACK  Ack & close connection	CALL	Do_TCP_Wflags	; we must acknolage the tcp packet now;	mBank2	BTFSS	eeROMbuff.len,7	GOTO	TFTPPortE_handler_2	MOVFW	eeROMbuff.len	ANDLW	0x0F	; bank # 0..F, 16 32KB banks max.	mCall1To0	CopyEEROMtoSRAM	;  or we will timeout here.	RETURN;TFTPPortE_handler_2	mCall1To0	EraseEEROM	RETURN	endif;; test for valid length 1..32TFTPPortE_handler_1	MOVFW	eeROMbuff.len	SUBLW	eeROMBuffLen	; 20-Len	SKPNB		; skip if not borrow	GOTO	S1_Bank0Rtn	; len>20;; read Param7C bytes of data into bufferTFTPPortE_handler_L1	CALL	getch_net	; get the next data byte	BTFSC	atend	RETURN		; bad data, too short	MOVWF	INDF	INCF	FSR,F	DECFSZ	Param7C,F	GOTO	TFTPPortE_handler_L1;;;write data wait 5ms then read the data	mCall1To0	WriteEEROM	MOVLW	0x05	CALL	DelayWmS_D08	GOTO	TFTPPortE_Read;;==========================================================================================================; Read eeROMBuffLen bytes of data into NIC buffer and send it (tflags  Ack & close & Push);; Entry: eeROMbuff.Addr; Exit: tcp_xmit; Calls:() TFTPPortE_Read; RAM used:;TFTPPortE_ReadAll	mBank2	MOVLW	eeROMBuffLen	MOVWF	eeROMbuff.len;; fall through to TFTPPortE_Read;;==========================================================================================================; Read eeROMbuff.len bytes of data into NIC buffer and send it (tflags  Ack & close & Push);; Entry: eeROMbuff.len, eeROMbuff.Addr; Exit: tcp_xmit; Calls:(1+2) Std_TCP_Setup, ReadEEROM, putnic_checkbyte, tcp_xmit; RAM used: Param78, Param79, FSR; ; Send data to nic buffer, calc checksum ; 76 bytes max (IPHDR_LEN+TCPHDR_LEN+lenByte+Address+32 Data)TFTPPortE_Read	CALL	Std_TCP_Setup	MOVLW	IPHDR_LEN+TCPHDR_LEN	;txin = IPHDR_LEN + TCPHDR_LEN	MOVWF	txin	mCall1To0	ReadEEROM;;	MOVLW	low eeROMbuff.len	MOVWF	FSR	MOVWF	Param7A	; read next byte from here	BSF	STATUS,IRP	MOVF	INDF,W	ADDLW	0x04	; address and length header	MOVWF	Param79	; bytes to read;	TFTPPortE_Read_L2	MOVF	Param7A,W	MOVWF	FSR	BSF	STATUS,IRP	MOVF	INDF,W	CALL	putnic_checkbyte	INCF	Param7A,F	DECFSZ	Param79,F	GOTO	TFTPPortE_Read_L2;	MOVLW	TFIN+TACK+TPUSH	; tflags = TFIN+TACK  Ack & close connection	GOTO	Do_TCP_Wflags;		endif;=========================================================================================; Respond to an ICMP echo request message (aka ping);; Entry:; Exit: ; RAM used: ICMP header checksum (2 bytes) Param7B, Param7C; Calls:(1+) match_byteW, getch_net, skip_byte, put_ip, putch_net_W,;	put_ether, copy_rx_tx, xmit_ether;icmp_recv	mBank0	BCF	checkflag	; checkflag = 0 Clear checksum 	CLRF	checklo	; checklo = 0 	CLRF	checkhi	; checkhi = 0	CLRF	rpdlen_b1	; rpdlen = 0; 	CLRF	rpdlen_b0;	MOVLW	ICMP_ERequest	;ICMP type = ICMP_ERequest	CALL	match_byteW	BTFSS	Param78,0	RETURN;	CLRW		;ICMP Code = 0	CALL	match_byteW	BTFSS	Param78,0	RETURN;	CALL	getch_net	; get_word(csum)	MOVWF	Param7C	CALL	getch_net	MOVWF	Param7B	BTFSC	atend	RETURN; ; Check data icmp_recv_L1	CALL	skip_byte	BTFSS	Param78,0	GOTO	icmp_recv_1	; we already read the last byte;	INCFSZ	rpdlen_b0,F	; rpdlen++;	GOTO	icmp_recv_L1	INCF	rpdlen_b1,F	GOTO	icmp_recv_L1;icmp_recv_1	INCF	checkhi,W	;checkhi=0xff	BTFSS	STATUS,Z	RETURN		;bad csum	INCF	checklo,W	;checklo=0xff	BTFSS	STATUS,Z	RETURN		;bad csum;	MOVF	rpdlen_b1,F	;rpdlen<=MAXPING_LEN	BTFSS	STATUS,Z	RETURN		;>=0x100, too big;	MOVLW	MAXPING_LEN+1	SUBWF	rpdlen_b0,W	BTFSC	STATUS,C	RETURN		;it should have borrowed; If OK and not bcast.. 	CALL	put_ip	;IP header 	MOVLW	ICMP_EReply	; ICMP type 	CALL	putch_net_W	CLRW		; ICMP code (0)	CALL	putch_net_W; recalculate the ICMP checksum for resp;  we changed the ICMP type, which is a MSB from 0x08 to 0x00	MOVLW	0x08	; csum = csum+0x0800	ADDWF	Param7C,F; if (csum < 0x0800)	  ..including hi-lo carry 	MOVLW	0x08	SUBWF	Param7C,W	BTFSC	STATUS,C	GOTO	icmp_recv_2;	INCF	Param7B,F	; csum++; 	BTFSC	STATUS,Z	INCF	Param7C,F;icmp_recv_2	MOVF	Param7C,W	; put_word(csum);   ICMP checksum 	CALL	putch_net_W	MOVF	Param7B,W	CALL	putch_net_W; Move what we have so far to the NIC tx buffer;  adding the ethernet header	CALL	put_ether	; put_ether(txbuff, txin);; Send ICMP echo response; send back the last 4 bytes of the ICMP header and the data,;  don't look at it just copy it from the NICs rx buffer;  to the NICs tx buffer	MOVF	txin,W	; copy_rx_tx(txin, IPHDR_LEN+ICMPHDR_LEN, rpdlen); 	MOVWF	Param79	MOVLW	IPHDR_LEN+ICMPHDR_LEN	MOVWF	Param7A	MOVF	rpdlen_b0,W	MOVWF	Param7B	CALL	copy_rx_tx; xmit_ether(IPHDR_LEN+ICMPHDR_LEN+rpdlen);	MOVLW	IPHDR_LEN+ICMPHDR_LEN	ADDWF	rpdlen_b0,W	MOVWF	Param7C	MOVF	rpdlen_b1,W	BTFSC	STATUS,C	ADDLW	0x01	MOVWF	Param7D	GOTO	xmit_ether	; transmit the ethernet frame;;;====================================================================================	; Put out a TCP segment header. (Source Port..Options); Data checksum must have already been computed.;; Entry: none; Exit:; RAM used: Param78, Param79, Param7A, Param7C, Param7D, FSR (verified 1/30/03); Calls:(1+1) putch_net_W, put_rack, put_rseq, check_MyIP, check_remip, check_byte_W;put_tcp	mBank0	BCF	checkflag	; checkflag = 0; Ensure we're on an even byte 	MOVF	d_checkhi,W	; checkhi = d_checkhi Retrieve data checksum 	MOVWF	checkhi	MOVF	d_checklo,W	; checklo = d_checklo; 	MOVWF	checklo;Source Port	MOVF	locport_b1,W	CALL	putch_net_W	MOVF	locport_b0,W	CALL	putch_net_W;Dest Port	MOVF	remport_b1,W	CALL	putch_net_W	MOVF	remport_b0,W	CALL	putch_net_W;Sequence number	CALL	put_rack;Acknowledgment Number	CALL	put_rseq;;TCP header length;if TSYN flag is set then header len is 4 bytes more because the MSS value is in the options area	MOVF	tflags,W	ANDLW	TSYN	BTFSC	STATUS,Z	GOTO	put_tcp_1	MOVLW	TCPSYN_LEN*4	GOTO	put_tcp_2put_tcp_1	MOVLW	TCPHDR_LEN*4put_tcp_2	CALL	putch_net_W;the reserved bits are always 0's; Code bits	MOVF	tflags,W	CALL	putch_net_W;Window size	MOVLW	high TCP_WDWSize	CALL	putch_net_W	MOVLW	low TCP_WDWSize	CALL	putch_net_W;	MOVF	tpxdlen,W	; len = tpxdlen + TCPHDR_LEN; 	ADDLW	TCPHDR_LEN	MOVWF	Param7C	;low len	MOVF	tpxdlen+1,W	MOVWF	Param7D	;high len	BTFSC	STATUS,C	INCF	Param7D,F	;high len;; if (tflags & TSYN) If sending SYN, send MSS option 	MOVF	tflags,W	ANDLW	TSYN	BTFSC	STATUS,Z	GOTO	put_tcp_3;  ; Put MSS in buffer after TCP header 	MOVLW	0x04	; txin += 4;	ADDWF	txin,F	; skip csum & urgent ptr;	MOVLW	TCPOPT_LEN	; len += TCPOPT_LEN; 	ADDWF	Param7C,F	BTFSC	STATUS,C	INCF	Param7D,F;Options (32 bits)	MOVLW	0x02	; putch_net(2); 	CALL	putch_net_W	MOVLW	0x04	; putch_net(4); 	CALL	putch_net_W;	MOVLW	high TCP_MSS	CALL	putch_net_W	MOVLW	low TCP_MSS	CALL	putch_net_W;; txin =txin-(TCPOPT_LEN + 4);  Go back to checksum in header 	MOVLW	TCPOPT_LEN+4	SUBWF	txin,F;;Checksum the pseudo header Src IP, Dest IP, 0x00 byte, IP protocol, lengthput_tcp_3	CALL	check_MyIP;	CALL	check_remip;	CLRW	CALL	check_byte_W	MOVLW	PTCP	CALL	check_byte_W;	MOVF	Param7D,W	; check_word(len);	CALL	check_byte_W	MOVF	Param7C,W	CALL	check_byte_W;; Send checksum 	COMF	checkhi,W	CALL	putch_net_W;	COMF	checklo,W	CALL	putch_net_W;	CLRW		;Urgent ptr (not used)	CALL	putch_net_W	CLRW	CALL	putch_net_W;; if (tflags & TSYN)	  Adjust Tx ptr if sending MSS option 	MOVF	tflags,W	ANDLW	TSYN	BTFSC	STATUS,Z	RETURN;re-adjust buffer offset	MOVLW	TCPOPT_LEN	; txin=txin+TCPOPT_LEN; 	ADDWF	txin,F	RETURN;;===========================================================================================; Transmit a TCP segment;; Entry:data at txbuff, txin=data length, data csum in d_checkhi,d_checklo;	tpxdlen = length of data in NIC buffer ; Exit:; RAM used: Param71, Param78, Param79, Param7A, Param7B, Param7C, Param7D, FSR (verified 1/30/03); Calls:(1+2) put_ip, put_tcp, put_ether, xmit_ether; tcp_xmit	mBank0	MOVF	tpxdlen,W	;iplen:=tpxdlen+IPHDR_LEN+TCPHDR_LEN	MOVWF	iplen_b0	MOVF	tpxdlen+1,W	MOVWF	iplen_b1	MOVLW	IPHDR_LEN+TCPHDR_LEN	ADDWF	iplen_b0,F	BTFSC	STATUS,C	INCF	iplen_b1,F; if (tflags & TSYN) allow for MSS option 	MOVF	tflags,W	ANDLW	TSYN	BTFSC	STATUS,Z	GOTO	tcp_xmit_1;	MOVLW	TCPOPT_LEN	; iplen += TCPOPT_LEN; 	ADDWF	iplen_b0,F	BTFSC	STATUS,C	INCF	iplen_b1,F; IP header tcp_xmit_1	CALL	put_ip	; IP header	CALL	put_tcp	; TCP header 			; put_ether(txbuff, txin);  Send to NIC;;====================================; Transmit ethernet header and data;; Calls:(1+2) put_ether(1+1), xmit_ether(1+0);tcp_xmit_2	CALL	put_ether	; Ethernet header and data;	MOVF	txin,W	; xmit_ether(txin+tpxdlen);  Transmit 	ADDWF	tpxdlen,W	MOVWF	Param7C	MOVF	tpxdlen+1,W	MOVWF	Param7D	BTFSC	STATUS,C	INCF	Param7D,F	;carry;	GOTO	xmit_ether; 	if UsesUDP;======================================================================================================; Test a User Datagram to see if it is valid; ; Entry: NIC buffer pointer points to first byte of UDP Header; Exit: NIC buffer pointer points to first byte of the datagram Data field;       if this is a Valid UDP datagram we fall through to udp_handler; RAM used: Param76, Param77, Param78, Param79, Param7A, Param7B; Calls:(1+ ) getch_net, skip_word, check_byte_W, getnic_addr, setnic_addr, check_rxbytes;UDP_recv	CLRF	checklo	; checkhi = checklo = 0; 	CLRF	checkhi;	if UDPtesting	MOVLW	0x03	CALL	lcd_GotoLineW_D08	MOVLW	'U'	CALL	DisplaysW_D08	endif;; Source Port (2 bytes) 0 or where to send replies	CALL	getch_net	MOVWF	remport_b1	CALL	getch_net	MOVWF	remport_b0; Destination Port (2 bytes) application port	CALL	getch_net	MOVWF	locport_b1	CALL	getch_net	MOVWF	locport_b0;	if UDPtesting	CALL	Disp_Hex_Byte_D08	endif;; Message length (2 bytes) including header (8..1480)	CALL	getch_net	MOVWF	Param7D	CALL	getch_net	MOVWF	Param7C	BTFSC	atend	RETURN;; skip:  csum 	CALL	skip_word	BTFSC	atend	RETURN;	BSF	Param70,0	CLRF	Param77	CALL	CheckPseudo;; check the rest of the bytes in the datagram, but leave them in the rx buffer; check_rxbytes(iplen-TCPHDR_LEN);  77:76=byte count	MOVF	iplen_b0,W	;iplen	MOVWF	Param76	MOVLW	UDPHDR_LEN	SUBWF	Param76,F	MOVF	iplen_b1,W	MOVWF	Param77	BTFSS	STATUS,C	DECF	Param77,F	CALL	check_rxbytes;; restore ptr so next byte we get is the first data byte; setnic_addr(addr) 	CALL	setnic_addr; if (checkhi=0xff) and (checklo=0xff) then this data is a valid UPD datagram;	INCF	checkhi,W	BTFSS	STATUS,Z	RETURN		;bad csum	INCF	checklo,W	BTFSS	STATUS,Z	RETURN		;bad scum;; fall through to udp_handler;==============================================================================================; Handle an incomming UDP datagram; Entry: A valid datagram data field in the NIC's ram;        Param7C, Param7D= Length of data LSB, MSB; Exit:; RAM used:; Calls:();udp_handler;	if UDPtesting	MOVLW	'D'	CALL	DisplaysW_D08	endif;udp_handler_Ports	MOVLW	high TermPort	SUBWF	locport_b1,W	BTFSS	STATUS,Z	GOTO	udp_handler_Ports1	MOVLW	low TermPort	SUBWF	locport_b0,W	BTFSC	STATUS,Z	GOTO	udp_handler_TermPort;udp_handler_Ports1	MOVLW	high IPDATAPORT	SUBWF	locport_b1,W	BTFSS	STATUS,Z	GOTO	udp_handler_Ports2	MOVLW	low IPDATAPORT	SUBWF	locport_b0,W	BTFSC	STATUS,Z	GOTO	udp_handler_DataPort;udp_handler_Ports2			; Unrecognised port;	RETURN;; Recognised ports;udp_handler_TermPort	BSF	PCLATH,4	;segment 3	GOTO	UDP_Term_Handler	;udp port 57 handler in segment 3;;udp_handler_DataPort	BSF	PCLATH,4	;segment 3	GOTO	UDP_Data_Handler	;udp port 87 handler in segment 3;	endif;;=================================================================================; Set NIC reset signal high (Active);; Entry: none; Exit: none; RAM used: Param77, Param78, Param79 (verified 3/14/05); Calls:(1+1) DelayWmS_D08, WriteLDO_0_D08;reset_ether	MOVLW	0x20	CALL	DelayWmS_D08	; power up delay	mBank3	BSF	CMD_LDO_0,NIC_Reset	GOTO	WriteLDO_0_D08;;;========================================================================================; Initialise NIC.; Loops forever if NIC error.;; Entry: none; Exit: none; RAM used: Param70, Param71, Param77, Param78, Param79, FSR; Calls: (1+4) reset_ether, DelayWmS_D08, innic, outnicD78W, PrintString_D08,;	outnic_CMDR_W, outnic_BNRY_W, outnic_ISR_FF, outnic_RCR_W, outnic_TCR_W; init_ether	CALL	reset_ether	MOVLW	0x02	; delay_ms(2);	CALL	DelayWmS_D08; un-reset ether	mBank3	BCF	CMD_LDO_0,NIC_Reset	CALL	WriteLDO_0_D08;	MOVLW	0x02	; delay_ms(2); 	CALL	DelayWmS_D08	CALL	innic_NE_RESET	; outnic(NE_RESET, innic(NE_RESET)) Do reset 	MOVLW	NE_RESET	CALL	outnicD78W	MOVLW	0x02	; delay_ms(2); 	CALL	DelayWmS_D08; if ((innic(ISR) & 0x80) == 0)  Report if failed	CALL	innic_ISR	BTFSC	Param78,7	GOTO	init_ether_NoErr;;Display the error string	if UsesLCD	MOVLW	NICinitErrStrPtr	;"\nNIC init err " 	CALL	PrintString_D08	;loop until init'd or forever	mCall1To0	Delay1Sec	;delay 1 second	endif	GOTO	init_ether;init_ether_NoErr	MOVLW	0x21	; outnic(CMDR, 0x21) Stop, DMA abort, page 0 	CALL	outnic_CMDR_W	MOVLW	0x02	; delay_ms(2) ..wait to take effect 	CALL	DelayWmS_D08	MOVLW	DCRVAL	; outnic(DCR, DCRVAL); 	MOVWF	Param78	MOVLW	DCR	CALL	outnicD78W	CLRW		; outnic(RBCR0, 0) Clear remote byte count  	CALL	outnic_RBCR0_W	CALL	outnic_RBCR1_0	; outnic(RBCR1, 0); 	MOVLW	0x20	; outnic(RCR, 0x20) Rx monitor mode	CALL	outnic_RCR_W	MOVLW	0x02	; outnic(TCR, 0x02) Tx internal loopback 	CALL	outnic_TCR_W;	MOVLW	TXSTART	; outnic(TPSR, TXSTART) Set Tx start page 	MOVWF	Param78	MOVLW	TPSR	CALL	outnicD78W;	MOVLW	RXSTART	; outnic(PSTART, RXSTART) Set Rx start, stop, boundary	MOVWF	Param78	MOVLW	PSTART	CALL	outnicD78W;	MOVLW	RXSTOP	; outnic(PSTOP, RXSTOP); 	MOVWF	Param78	MOVLW	PSTOP	CALL	outnicD78W;	MOVLW	RXSTOP-1	; outnic(BNRY, (BYTE)(RXSTOP-1));	CALL	outnic_BNRY_W	CALL	outnic_ISR_FF	; outnic(ISR, 0xff) Clear interrupt flags;	CLRF	Param78	; outnic(IMR, 0) Mask all interrupts	MOVLW	IMR	CALL	outnicD78W;	MOVLW	0x61	; outnic(CMDR, 0x61) Stop, DMA abort, page 1	CALL	outnic_CMDR_W	MOVLW	0x02	; delay_ms(2); 	CALL	DelayWmS_D08; Set Physical addr (MAC address) (6 bytes)	MOVLW	PAR0	MOVWF	Param7A	;nic reg address	MOVLW	myeth0	MOVWF	FSR	;data ptr	BCF	STATUS,IRP	MOVLW	MACLEN	MOVWF	Param79	;Countinit_ether_L1	MOVF	INDF,W	;myeth0..myeth5	MOVWF	Param78	;data	MOVF	Param7A,W	CALL	outnicD78W	; outnic(PAR0+i, myeth[i]); 	INCF	Param7A,F	INCF	FSR,F	DECFSZ	Param79,F	GOTO	init_ether_L1;; for (i=0; i<8; i++) Multicast accept-all	CLRF	Param7A	;Count	MOVLW	MAR0	MOVWF	Param79	;addr	MOVLW	0xFF	MOVWF	Param78	;datainit_ether_L2	MOVLW	0x08	SUBWF	Param7A,W	BTFSC	STATUS,C	GOTO	init_ether_1	;exit loop	MOVF	Param79,W	; outnic(MAR0+i, 0xff); 	CALL	outnicD78W	INCF	Param7A,F	INCF	Param79,F	GOTO	init_ether_L2;; outnic(CURRP, RXSTART+1) Set current Rx pageinit_ether_1	MOVLW	RXSTART+1	MOVWF	Param78	MOVLW	CURRP	CALL	outnicD78W; next_page = RXSTART + 1; 	MOVLW	RXSTART+1	MOVWF	next_page	MOVLW	0x20	; outnic(CMDR, 0x20) DMA abort, page 0	CALL	outnic_CMDR_W	MOVLW	0x04	; outnic(RCR, 0x04) Accept broadcasts 	CALL	outnic_RCR_W	CLRW		; outnic(TCR, 0) Normal Tx operation	CALL	outnic_TCR_W	CALL	outnic_ISR_FF	; outnic(ISR, 0xff) Clear interrupt flags	MOVLW	0x22	; outnic(CMDR, 0x22) Start NIC	GOTO	outnic_CMDR_W;;=======================================================================================;=======================================================================================;  Input a byte from NIC register NE_RESET;; Entry: none; Exit: W & Param78=Data; RAM used: Param78 (verified 10/2/02); Calls:(0) none;innic_NE_RESET	MOVLW	NE_RESET	GOTO	innic;;=======================================================================================;  Input a byte from NIC register CURRP, current page reg for rd and wr;; Entry: none; Exit: W & Param78=Data; RAM used: Param78 (verified 10/2/02); Calls:(0) none;innic_CURRP	MOVLW	CURRP	GOTO	innic;;=======================================================================================;  Input a byte from NIC register ISR, interrupt status reg for rd and wr;; Entry: none; Exit: W & Param78=Data; RAM used: Param78 (verified 10/2/02); Calls:(0) none;innic_ISR	MOVLW	ISR	GOTO	innic;;=======================================================================================;  Input a byte from NIC register RSAR0, low byte of remote start addr;; Entry: none; Exit: W & Param78=Data; RAM used: Param78 (verified 10/2/02); Calls:(0) none;innic_RSAR0	MOVLW	RSAR0	GOTO	innic;;=======================================================================================;  Input a byte from NIC register RSAR1, hi byte of remote start addr;; Entry: none; Exit: W & Param78=Data; RAM used: Param78 (verified 10/2/02); Calls:(0) none;innic_RSAR1	MOVLW	RSAR1	GOTO	innic;;=======================================================================================;  Input a byte from NIC register DATAPORT;; Entry: none; Exit: W & Param78=Data; RAM used: Param78 (verified 10/2/02); Calls:(0) none;innic_Data	MOVLW	DATAPORT;; fall trough to innic;=======================================================================================;  Input a byte from a NIC register;; Entry: W=Address; Exit: W & Param78=Data; RAM used: Param78 (verified 10/2/02); Calls:(0) none;innic		if UsesRS232BufIO	BCF	_GIE	BTFSC	_GIE	GOTO	$-2	endif	mSet8bitAddr	mReadData	SelectNIC	MOVWF	Param78	if UsesRS232BufIO	BSF	_GIE	endif	RETURN;;============================================================================================; Data in W to RSAR0; entry:W=value for RSAR0; exit: none; RAM used: Param71 (verified 10/2/02); Calls: (0) outnic_W;outnic_RSPR0_W	MOVWF	Param71	MOVLW	RSAR0	GOTO	outnic_W;;===========================================================================; Data in W to RSAR1; entry:W=value for RSAR1; exit: none; RAM used: Param71 (verified 10/2/02); Calls: (0) outnic_W;outnic_RSPR1_W	MOVWF	Param71	MOVLW	RSAR1	GOTO	outnic_W;;===========================================================================; Data in W to BNRY; entry:W=value for BNRY; exit: none; RAM used: Param71 (verified 10/2/02); Calls: (0) outnic_W;outnic_BNRY_W	MOVWF	Param71	MOVLW	BNRY	GOTO	outnic_W;;===========================================================================; Data in W to TCR; entry:W=value for TCR; exit: none; RAM used: Param71 (verified 10/2/02); Calls: (0) outnic_W;outnic_TCR_W	MOVWF	Param71	MOVLW	TCR	GOTO	outnic_W;;===========================================================================; Data in W to RCR; entry:W=value for RCR; exit: none; RAM used: Param71 (verified 10/2/02); Calls: (0) outnic_W;outnic_RCR_W	MOVWF	Param71	MOVLW	RCR	GOTO	outnic_W;;===========================================================================; Set Hi byte of Byte Count to zero; entry:none; exit: none; RAM used: Param71 (verified 10/2/02); Calls: (0) outnic_W;outnic_RBCR1_0	CLRW;;;===========================================================================; Set Hi byte of Byte Count; entry: W=byte count; exit: none; RAM used: Param71 (verified 10/2/02); Calls: (0) outnic_W;outnic_RBCR1_W	MOVWF	Param71	MOVLW	RBCR1	GOTO	outnic_W;;===========================================================================; Set low byte of Byte Count to 1; entry: none; exit: none; RAM used: Param71 (verified 10/2/02); Calls: (0) outnic_W;outnic_RBCR0_1	MOVLW	0x01;;===========================================================================; Set low byte of Byte Count; entry: W=byte count; exit: none; RAM used: Param71 (verified 10/2/02); Calls: (0) outnic_W;outnic_RBCR0_W	MOVWF	Param71	MOVLW	RBCR0	GOTO	outnic_W;;;===========================================================================; outnic(CMDR, 0x0a) Start, DMA remote read; entry: none; exit: none; RAM used: Param71 (verified 10/2/02); Calls: (0) outnic_CMDR_W, outnic_W;outnic_CMDR_0A	MOVLW	0x0A; fall through to outnic_CMDR_W;;===========================================================================; Data in W to CMDR; entry: W=Data; exit: none; RAM used: Param71 (verified 10/2/02); Calls: (0) outnic_W;outnic_CMDR_W	MOVWF	Param71	CLRW	GOTO	outnic_W;;===========================================================================; outnicD78W   Data in Param78 Address in W; entry: W=Addr, Param78=Data; exit: Param78 unchanged; RAM used: Param70, Param71, Param78 (verified 10/2/02); Calls: (0) outnic_W;outnicD78W	MOVWF	Param70	MOVF	Param78,W	MOVWF	Param71	MOVF	Param70,W	GOTO	outnic_W;;===============================================================; outnic(ISR, 0xff);  Clear interrupt flags; Entry: none; Exit: none; RAM used: Param71 (verified 10/2/02); Calls: (0) outnic_ISR, outnic_W;outnic_ISR_FF	MOVLW	0xFF	MOVWF	Param71	GOTO	outnic_ISR;;===============================================================; Data in W to ISR; outnic(ISR, W);  Clear interrupt flags; Entry: W=value for ISR; Exit: none; RAM used: Param71 (verified 10/2/02); Calls: (0) outnic_ISR, outnic_W;outnit_ISR_W	MOVWF	Param71	GOTO	outnic_ISR;;===============================================================; outnic(ISR, 0x0A);  Clear interrupt flags; Entry: none; Exit: none; RAM used: Param71 (verified 10/2/02); Calls: (0) outnic_ISR, outnic_W;outnic_ISR_0A	MOVLW	0x0A	MOVWF	Param71	GOTO	outnic_ISR;;===============================================================; outnic(ISR, 0x40) Clear remote DMA interrupt flag; Entry: none; Exit: none; RAM used: Param71 (verified 10/2/02); Calls: (0) outnic_ISR, outnic_W;outnic_ISR40	MOVLW	0x40	MOVWF	Param71;;===============================================================; Write the value in Param71 to the NICs ISR register;; Entry: Param71=value for ISR; Exit: none; RAM used: Param71 (verified 10/2/02); Calls: (0) outnic_W;outnic_ISR	MOVLW	ISR;;===========================================================================; Output a byte to a NIC register; Entry: Param70=Address, Param71=Data; Exit: none; RAM used: Param71 (verified 10/2/02); Calls: (0) none;outnic_W		if UsesRS232BufIO	BCF	_GIE	BTFSC	_GIE	GOTO	$-2	endif	mSet8bitAddr	mWriteData	SelectNIC,Param71	if UsesRS232BufIO	BSF	_GIE	endif	RETURN;;;;