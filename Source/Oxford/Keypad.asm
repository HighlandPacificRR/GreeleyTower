	subtitle	"Keypad.asm"	page;	constant	TestingKeyPadIO=0;===========================================================================================;;  FileName: KeyPad.asm;  Date: 9/30/03;  File Version: 1.0.3;  ;  Author: David M. Flynn;  Company: Oxford V.U.E., Inc.;;============================================================================================; Revision History;; 1.0.3  9/30/03	Added short selection for * key "*&=#_:;+".;	Added comments for Data.inc file.; 1.0.2  9/2/03	Changed debounce to 2 no key downs w/ HexKeypadDebounce2; 1.0.1  8/25/03	Fixed a bug introduced by SRAM_ReadDR. (8 words saved); 1.0    8/6/03	All known bugs are fixed. Only symbols selection is missing.;	0x237 (567) Bytes. Little optimization has been done.; 1.0b4  8/6/03	Modified TextEntryIdle to delete all text when "C" key is held down.; 1.0b3  5/19/03	Added PrepForNumEntryL1;	Fixed a ninor bug where GetTextMask instead of GetNumMask; 1.0b2  5/17/03	Added FixCursor.; 1.0b1  5/16/03	All known bugs are fixed. Only symbols selection is missing.;	0x227 (551) Bytes; 1.0a6  5/16/03	Added SetDefaultText, KillDefaultText.;	Moved Falgs EQU's to this file. was Flags27 now KeyPadFlags1; 1.0a5  5/16/03	Added Scroll to center. Archived working rev.;	Still needs default string handling.; 1.0a4  5/14/03	Added support for arrow keys; 1.0a3  5/14/03	Added PrepForTextEntryL1; 1.0a2  4/21/03	Added KeypadConType.; 1.0a1  4/18/03	Added RepositionCursor, PrepForNumEntry, StrToMum.;	First working version w/ Text entry on line 0 only.;	Cancel timer and arrow keys not implemented at this time.; 1.0d3  4/15/03	Added PrepForTextEntry, HandleTextKey.; 1.0d2  4/14/03	Added Phone pad keys, KeyToAlpha.; 1.0d1  3/27/03	HexKeypadDebounce is now 1 bit in Flags27;	Added ValidKey; 1.0d0  3/25/03	First Code, first working GetHexKey;;============================================================================================; Notes:;;; This file has the driver for a 4x4 hex keypad.; Include after Main.asm in *** Segment 2 ***; There are no custom routines in this file.;; At this time (1.0.1) only symbol selection is not implemented.;  Symbol selection will be added later, memory permitting.;; Keypad connections (Hex Pad); Pin #	Description	Brain I/O	;  1	Row 1 (Keys 1,2,3,C)	LDI_8 (J2-33);  2	Row 2 (Keys 4,5,6,D)	LDI_9 (J2-34);  3	Row 3 (Keys 7,8,9,E)	LDI_10 (J2-35);  4	Row 4 (Keys A,0,B,F)	LDI_11 (J2-36);  5	Col 4 (Keys C,D,E,F)	LDO_8 (J1-25);  6	Col 3 (Keys 3,6,9,B)	LDO_9 (J1-26);  7	Col 2 (Keys 2,5,8,0)	LDO_10 (J1-27);  8	Col 1 (Keys 1,4,7,A)	LDO_11 (J1-28);  9	Shield Ground;	if KeypadConType=1KPLDO	EQU	CMD_LDO_1#Define	KPWriteLDO	WriteLDO_1#Define	KPReadLDI	ReadLDI_1	endif;; Keypad connections (Hex Pad); Pin #	Description	SR-1 Digital I/O	;  1	Row 1 (Keys 1,2,3,C)	LDI_16;  2	Row 2 (Keys 4,5,6,D)	LDI_17;  3	Row 3 (Keys 7,8,9,E)	LDI_18;  4	Row 4 (Keys A,0,B,F)	LDI_19;  5	Col 4 (Keys C,D,E,F)	LDO_16;  6	Col 3 (Keys 3,6,9,B)	LDO_17;  7	Col 2 (Keys 2,5,8,0)	LDO_18;  8	Col 1 (Keys 1,4,7,A)	LDO_19;  9	Shield Ground;	if KeypadConType=2KPLDO	EQU	CMD_LDO_2#Define	KPWriteLDO	WriteLDO_2#Define	KPReadLDI	ReadLDI_2		endif;; Keypad connections (Phone Pad); Pin #	Description	Brain I/O;  1	Row 1 (Keys PSE,1,2,3)	LDI_8 (J2-33);  2	Row 2 (Keys SPK,4,5,6)	LDI_9 (J2-34);  3	Row 3 (Keys RCL,7,8,9)	LDI_10 (J2-35);  4	Row 4 (Keys STO,*,0,#)	LDI_11 (J2-36);  5	Col 1 (Keys PSE,SPK,RCL,STO) LDO_8 (J1-25);  6	Col 2 (Keys 1,4,7,*)	LDO_9 (J1-26);  7	Col 3 (Keys 2,5,8,0)	LDO_10 (J1-27);  8	Col 4 (3,6,9,#)	LDO_11 (J1-28);  9	Tone Sw.	; 10	Tone/Pulse Com.	; 11	Pulse Sw.	; 12	Grn LED Anode/Red LED Cathode; 13	Red LED Anode/Grn LED Cathode;; Text entry key convertions for Hex pad (phone pad); Hex	Key	Text or Do;-----------------------------------------------------------------------------;  0	0	Space 0;  1	1	.,'?!@-1;  2	2 ABC	ABC2;  3	3 DEF	DEF3;  4	4 GHI	GHI4;  5	5 JKL	JKL5;  6	6 MNO	MNO6;  7	7 PQRS	PQRS7;  8	8 TUV	TUV8;  9	9 WXYZ	WXYZ9;  A	A(*)	Select from list .,@?!:;-+#*()'"_&$%/<>=;  B	B(#)	Uppercase/Lowercase toggle;  C	C(STO)(C)	Cancel/Delete;  D	D(PSE)(-)	Menu/OK/everything key;  E	E(SPK)(>)	Next/Up/Right/More;  F	F(RCL)(<)	Prev/Down/Left/Less;; Normal sequence of events:;;  Store the valid key mask in ValidKeyMask (2 bytes Big Endien);  Call GetHexKey if Param78,7 is set then a key has been pressed.;  If a key has been pressed Call KeyToHex to convert the key# to a Hex digit.;  Call ValidKey to see if the key is valid in this mode/task.; ;=================================================================================================; Name	(additional stack words required) Description 	(Bank);=================================================================================================;Routines:;;public:; SetKeyMask	(1+1) Move the keymask from SRAM(evDataROM) into ValidKeyMask; ValidKey	(0)   Test the hex value to see if it is valid for this task; GetHexKey	(1+1) Read the keypad return key number in W; KeyToHex	(1+0) Translate a key number to a hex digit; TextEntryIdle	(1+3) Multikey timeout handler (called OnTheTick) (1+4 testing) ; FixCursor	(0+2) If text entry is active goto RepositionCursor; HandleTextKey	(1+4) Handle text entry keypress; PrepForNumEntryL1	(1+4) Prepare for numeric text entry on Line 1; PrepForNumEntry	(1+4) Prepare for numeric text entry on Line 0; PrepForStr31Entry	(1+4) Prepare for text entry on line 1 Str31; PrepForTextEntryL1	(1+4) Prepare for text entry on line 1; PrepForTextEntry	(1+4) Prepare for text entry on line 0; SetDefaultText	(1+3) Setup to use Default text of length W; StrToMum	(1+1) Convert text in buffer into a 16 bit number in Param77:Param76.;;private:; KillDefaultText	(0)   Kill the Default Text; DoAutoScroll	(0)   Adjust DispOffset to keep InsertionOffset visible; IncCharsInBuff	(0)   if CharsInBuff<MaxTextLen then CharsInBuff++	(3); IncInsOffset	(0)   if InsertionOffset<CharsInBuff then InsertionOffset++	(3); DecInsOffset	(0)   if InsertionOffset<>0 then InsertionOffset--	(3); RestartKeyTimer	(0)   Resets the auto-enter char timer for text entry; RedrawText	(1+2) Redraw the text in the buffer; RepositionCursor	(1+1) Position Cursor on line 0 or 1 for text entry.; DeleteChar	(1+2) Delete a char at the insertion offset; InsertChar	(1+2) Add a char to the buffer at the insertion offset; BufferChar	(1+1) Put the current char in the buffer at the current insertion offset; KeyToAlpha	(1+1) Translate a key number to an ascii value;;;============================================================================================; Key usage constants;kSelectSymbolsKey	EQU	0x0AkUpperLowerToggleKey	EQU	0x0BkCancelKey	EQU	0x0CkOkEnterKey	EQU	0x0DkUpNextKey	EQU	0x0EkDownPrevKey	EQU	0x0F;kKeyTime	EQU	0x00FF	;1 second;; Bank0 flags;KeyPadFlags1 bits#Define	HexKeypadDebounce	KeyPadFlags1,0	;used to debounce the keypad#Define	KeyIsValid	KeyPadFlags1,1	;set if key is valid#Define	FirstPass	KeyPadFlags1,2	;KeyToAlpha flag to clr index#Define	UpperCase	KeyPadFlags1,3	;Set for Upper Case CharsUCMask	EQU	b'00001000'#Define	EntryDone	KeyPadFlags1,4	;Set when text entry is done#Define	TextEntryActive	KeyPadFlags1,5	;Set when text entry is in progress#Define	NumbersOnly	KeyPadFlags1,6	;Set to restrict text entry to 0..9;#Define	TextEntryLine1	KeyPadFlags1,7	;Set to enter text on line 1,			; clr for line 0;KeyPadFlags2 bits#Define	UseDefaultText	KeyPadFlags2,0	;Set before default text is accepted#Define	HexKeypadDebounce2	KeyPadFlags2,1	;used to debounce the keypad longer;;============================================================================================; Add to Data.inc file;;GetNumMask	DW	b'1111001111111111'	;<> E)nter, C)ancel, 0..9;GetTextMask	DW	b'1111111111111111'	;0..9, E)nter, C)ancel, D>>back, F>>forward;; Data table for converting Hex key to text; Characters are based on the NOKIA model.; 8 bytes for each Hex key 0..9;KeyData	DB	' ','0',0,0,0,0,0,0;	DB	'.',0x2C,'\'','?','!','@','-','1'	;0x2C=',';	DB	'A','B','C','2',0,0,0,0;	DB	'D','E','F','3',0,0,0,0;	DB	'G','H','I','4',0,0,0,0;	DB	'J','K','L','5',0,0,0,0;	DB	'M','N','O','6',0,0,0,0;	DB	'P','Q','R','S','7',0,0,0;	DB	'T','U','V','8',0,0,0,0;	DB	'W','X','Y','Z','9',0,0,0;; There are 23 Special Chars;SpecialChars	DB	'*',&,'=','#','_',':',0x3B,'+'	;0x3B=';';	DB	'+','#','*','(','),'\'','"','_';	DB	'&','$','%','/','<','>','=';;============================================================================================; Move the keymask from SRAM(evDataROM) into ValidKeyMask;; Entry: W=Key Mask Offset; Exit: ValidKeyMask = data from SRAM(evDataROM+W); RAM used: none; Calls: (1+1) SRAM_ReadPI, SRAM_Read;SetKeyMask	mCall2To0	SRAM_ReadDR	BSF	STATUS,RP1	;Bank2	MOVWF	ValidKeyMask	mCall2To0	SRAM_Read	BSF	STATUS,RP1	;Bank2	MOVWF	ValidKeyMask+1MainBank0Rtn	mBank0	RETURN;;================================================================================================;Test the hex value to see if it is valid for this task;; Entry: Hex digit in W; Exit: Hex digit in W and Param78, KeyIsValid set/cleared; RAM used: Param78, Param79, Param7A, Param7B; Calls:(0) none;;ValidKey	BSF	KeyIsValid	;default to valid	MOVWF	Param78	MOVWF	Param79	INCF	Param79,F	;make it 1..16	CLRF	Param7A	;MSB	CLRF	Param7B	;LSB	BSF	STATUS,CValidKey_L1	RLF	Param7B,F	RLF	Param7A,F	DECFSZ	Param79,F	GOTO	ValidKey_L1	mBank2	MOVF	Param7B,W	ANDWF	ValidKeyMask+1,W	SKPZ	GOTO	ValidKey_GoodKey	MOVF	Param7A,W	ANDWF	ValidKeyMask,W	SKPZ	GOTO	ValidKey_GoodKey	mBank0	BCF	KeyIsValidValidKey_GoodKey	MOVF	Param78,W	GOTO	MainBank0Rtn;;================================================================================================;Get a key from the hex keypad;Hi bit set indicates a valid key number in lower nibble.;; Entry: none; Exit: Key number (None pressed=0x00 or 0..F=0x80..0x8F) in Param78 and W; RAM used: Param78, Param79, Param7A; Calls:(1+1) WriteLDO_1, ReadLDI_1;;GetHexKey	mBank0	MOVLW	0xF7	MOVWF	Param79	;Col# Bit Mask	MOVLW	0x04	MOVWF	Param7A	;Col# (3..0);GetHexKey_1	INCF	Param79,W	;Param79=0xFF ?	SKPNZ	GOTO	GetHexKey_NoKey	;Yes	mBank3	MOVLW	0x0F	;No	IORWF	KPLDO,F	;Set Col bits	MOVF	Param79,W	;Clr 1 Col bit	ANDWF	KPLDO,F;	BSF	STATUS,C	RRF	Param79,F	;shift mask	DECF	Param7A,F	;dec col#	mCall2To0	KPWriteLDO	mCall2To0	KPReadLDI	MOVWF	Param78	MOVLW	0xF0	IORWF	Param78,F	INCF	Param78,W	;Param78=0xFF?	SKPNZ	GOTO	GetHexKey_1	;Yes, no key pressed;	BCF	STATUS,C	RLF	Param7A,F	;Col# * 4	RLF	Param7A,F	BTFSS	Param78,0	;Row 1 Key?	MOVLW	0x80		;Yes	BTFSS	Param78,1	;Row 2 Key?	MOVLW	0x81	BTFSS	Param78,2	;Row 3 Key?	MOVLW	0x82	BTFSS	Param78,3	;Row 4 Key?	MOVLW	0x83	IORWF	Param7A,W	MOVWF	Param78	;Key#;	BTFSC	HexKeypadDebounce	;Key still down?	GOTO	GetHexKey_StillDown	;yes	MOVF	Param78,W	BSF	HexKeypadDebounce	BSF	HexKeypadDebounce2	RETURN;GetHexKey_NoKey	BTFSS	HexKeypadDebounce2	BCF	HexKeypadDebounce	BCF	HexKeypadDebounce2GetHexKey_StillDown	CLRF	Param78	RETLW	0x00;	;===============================================================================================;Translate a key number to a hex digit;; Entry: Key# in W; Exit: Hex digit in W; RAM used: Param78; Calls:(1+0) ReadEEwW;KeyToHex	MOVWF	Param78	MOVLW	0x0F	ANDWF	Param78,W	ADDLW	eHexKeys	GOTO	ReadEEwW_D10;	;===============================================================================================; Multikey timeout handler (called OnTheTick);; if (Timer2Lo=0) and (LastKeyDown in {0..9}) then;  {LastKeyDown=0xFF;   FirstPass=true;   if CharsInBuff<>MaxTextLen then CharsInBuff++;   reposition cursor }; else if (Timer2Lo=0) and (LastKeyDown = C) and (CharsInBuff>0) and HexKeypadDebounce then;  {LastKeyDown=0xFF;   FirstPass=true;   CharsInBuff=0;   reposition cursor};; Entry: none; Exit:; RAM used: none; Calls: (1+3) RepositionCursor, IncInsOffset;TextEntryIdle	mBank3	MOVF	Timer2Lo,W	IORWF	Timer2Hi,W	SKPZ		;Timed out?	GOTO	MainBank0Rtn	;No;	MOVLW	d'10'	SUBWF	LastKeyDown,W	;LastKeyDown-10	SKPB		;LastKeyDown<=9	GOTO	TEI_DelAll	;No;	MOVLW	0xFF	MOVWF	LastKeyDown;	CALL	IncInsOffset	mBank0	BSF	FirstPass;		GOTO	RedrawText;TEI_DelAll	MOVLW	kCancelKey	SUBWF	LastKeyDown,W	;LastKeyDown=kCancelKey?	SKPZ	GOTO	MainBank0Rtn	; no;	TSTF	CharsInBuff	SKPNZ		;CharsInBuff>0?	GOTO	MainBank0Rtn	;No;	mBank0	BTFSS	HexKeypadDebounce	;key still down?	GOTO	MainBank0Rtn	;no	mBank3	MOVLW	0xFF	MOVWF	LastKeyDown	CLRF	CharsInBuff	CLRF	InsertionOffset	GOTO	RedrawText;;================================================================================================; If text entry is active goto RepositionCursor;; Entry:TextEntryActive, CharsInBuff, MaxTextLen, DispXYPos; Exit: none; RAM used: Param78, Param79 (verified 4/18/03); Calls: (0+2) RepositionCursor;FixCursor	mBank0	BTFSC	TextEntryActive	GOTO	RepositionCursor	RETURN;;================================================================================================; Handle text entry keypress;; Entry: Param7C=Hex Key Value; Exit:; RAM used: Param78, Param79, Param7A, Param7B, Param7C; Calls:(1+2) KeyToAlpha, lcd_gotoxy_NC_D10;HandleTextKey	mBank3	MOVFW	Param7C	SUBWF	LastKeyDown,W	SKPNZ	GOTO	htkSameKey;This is a different key.;if not timed out then IncInsOffset	MOVF	Timer2Lo,W	IORWF	Timer2Hi,W	SKPZ		;Timed out?	CALL	IncInsOffset	;No	mBank0	BSF	FirstPass	mBank3htkSameKey	MOVF	Param7C,W	MOVWF	LastKeyDown;htkProcessIt	mBank0	MOVLW	kOkEnterKey	SUBWF	Param7C,W	SKPNZ		;Key = kOkEnterKey?	GOTO	htkOK	;Yes;	MOVLW	kCancelKey	SUBWF	Param7C,W	SKPNZ		;Key = kCancelKey?	GOTO	htkCancel	;Yes;	MOVLW	kUpNextKey	SUBWF	Param7C,W	SKPNZ		;Key = kUpNextKey?	GOTO	htkNext	;Yes;	MOVLW	kDownPrevKey	SUBWF	Param7C,W	SKPNZ		;Key = kDownPrevKey?	GOTO	htkPrev	;Yes;	CALL	KillDefaultText;; this has been commented out to allow selection from next 8 chars in table;;	MOVLW	kSelectSymbolsKey	;0x0A,'*','Yes';	SUBWF	Param7C,W;	SKPNZ		;Key = kSelectSymbolsKey?;	GOTO	htkSelectSymbol	;Yes;	MOVLW	kUpperLowerToggleKey	;0x0B,'u/l','No'	SUBWF	Param7C,W	SKPNZ		;Key = kUpperLowerToggleKey?	GOTO	htkULcToggle	;Yes;; handle 0..9 keys  and A "*"	BTFSC	NumbersOnly	BSF	FirstPass	CALL	KeyToAlpha	BTFSS	FirstPass	CALL	BufferChar	BTFSC	FirstPass	;FirstPass?	CALL	InsertChar	;Yes, Insert a new char.	BCF	FirstPass	BTFSC	NumbersOnly	CALL	IncInsOffset	CALL	RedrawText;	GOTO	RestartKeyTimer;;htkPrev	BCF	UseDefaultText	;accept default text for editting	CALL	DecInsOffset	GOTO	htkNext_1;htkNext	BCF	UseDefaultText	;accept default text for editting	CALL	IncInsOffsethtkNext_1	CALL	RedrawText	GOTO	htkReturn;; handle C key pressed; if CharsInBuff=0 then cancel entry; else delete charhtkCancel	mBank3	TSTF	CharsInBuff	SKPNZ	GOTO	htkDoCancel;	CALL	DeleteChar	CALL	RedrawText	CALL	RestartKeyTimer	GOTO	htkReturn;htkDoCancel	mBank0	BSF	escaped	GOTO	htkCanceled	;htkOK	BSF	EntryDonehtkCanceled	BCF	TextEntryActive	mCall2To0	lcd_OnhtkReturn;	mBank3;	MOVLW	0xFF;	MOVWF	LastKeyDown	mBank0	BSF	FirstPass	RETURN;htkULcToggle	MOVLW	UCMask	XORWF	KeyPadFlags1,F	GOTO	htkReturn;;htkSelectSymbol	GOTO	htkReturn	;Not Implemented;;============================================================================================; Prepare for numeric text entry on Line 1;; Entry: W=Display X pos of first char, Bank0 selected; Exit: none; RAM used: Param78, Param79 (verified 4/18/03); Calls: (1+2) RepositionCursor, lcd_Cursor;PrepForNumEntryL1	BSF	TextEntryLine1	GOTO	PrepForNumEntry_1;;============================================================================================; Prepare for numeric text entry on Line 0;; Entry: W=Display X pos of first char, Bank0 selected; Exit: none; RAM used: Param78, Param79 (verified 4/18/03); Calls: (1+2) RepositionCursor, lcd_Cursor;PrepForNumEntry	BCF	TextEntryLine1PrepForNumEntry_1	BSF	NumbersOnly	MOVWF	Param79	MOVLW	0x05	;5 chars max	MOVWF	Param78	MOVFW	Param79	GOTO	PrepForTextEntry_1;;============================================================================================; Prepare for text entry on line 1 Str31;; Entry: none, Bank0 selected; Exit: none; RAM used: Param78, Param79 (verified 8/6/03); Calls: (1+2) RepositionCursor, lcd_Cursor;PrepForStr31Entry	MOVLW	0x1F	;31 Chars Max	MOVWF	Param78	MOVLW	0x00	;Disp X=0;; fall through to PrepForTextEntryL1;;============================================================================================; Prepare for text entry on line 1;; Entry: Param78=Max Chars, W=Display X pos of first char, Bank0 selected; Exit: none; RAM used: Param78, Param79 (verified 4/18/03); Calls: (1+2) RepositionCursor, lcd_Cursor;PrepForTextEntryL1	BSF	TextEntryLine1	BCF	NumbersOnly	GOTO	PrepForTextEntry_1;;============================================================================================; Prepare for text entry on line0;; Entry: Param78=Max Chars, W=Display X pos of first char, Bank0 selected; Exit: none; RAM used: Param78, Param79 (verified 4/18/03); Calls: (1+3) RedrawText, lcd_Cursor;PrepForTextEntry	BCF	NumbersOnly	BCF	TextEntryLine1PrepForTextEntry_1	BSF	FirstPass	;FirstPass=true	BSF	UpperCase	;UpperCase=true	BCF	escaped	;escaped=false	BCF	EntryDone	;Done=false	BSF	TextEntryActive	BCF	UseDefaultText	mBank3	MOVWF	DispXYPos	SUBLW	LCD_ChrsPerLine	;LCD_ChrsPerLine-DispXYPos	MOVWF	DispFieldWidth	MOVF	Param78,W	ANDLW	0x1F	;allow 1..31 chars	SKPNZ	MOVLW	0x08	; default to 8	MOVWF	MaxTextLen;; if DispFieldWidth>MaxTextLen then DispFieldWidth=MaxTextLen;	SUBWF	DispFieldWidth,W	;DispFieldWidth-MaxTextLen	SKPNB		;MaxTextLen<=DispFieldWidth?	GOTO	PrepForTextEntry_2	;No	MOVFW	MaxTextLen	;Yes, DispFieldWidth=MaxTextLen	MOVWF	DispFieldWidth;PrepForTextEntry_2	CLRF	DispOffset	CLRF	InsertionOffset	MOVLW	0xFF	MOVWF	LastKeyDown	;no key	CLRF	CharsInBuff	CALL	RedrawText	;was RepositionCursor	mCall2To0	lcd_Cursor	MOVLW	GetTextMask	BTFSC	NumbersOnly	MOVLW	GetNumMask	GOTO	SetKeyMask;;==============================================================================================; Setup to use Default text of length W;; Entry: W = length of text; Exit: none; RAM used: Param78, Param79; Calls:(1+3) RedrawText;SetDefaultText	mBank3	MOVWF	CharsInBuffSetDefaultText_E2	mBank0	BSF	UseDefaultText	GOTO	RedrawText;;==============================================================================================; Convert text in buffer into a 16 bit number.;; Entry: CharsInBuff; Exit: Param77:Param76  16 bit value; RAM used: Param76, Param77, Param78, Param79, Param7A, Param7B; Calls: (1+1) Times10, SRAM_ReadPI;StrToMum	mBank3	MOVF	CharsInBuff,W	ANDLW	0x07	;limit to 7 chars	MOVWF	Param78	SKPNZ		;Zero length string?	GOTO	MainBank0Rtn	; yes	CLRF	SRAM_Addr0	MOVLW	low evKeyboardBuff	MOVWF	SRAM_Addr1	MOVLW	high evKeyboardBuff	MOVWF	SRAM_Addr2		CLRF	Param77	mCall2To0	SRAM_ReadPI	;Get first char	MOVWF	Param76	MOVLW	'0'	;W=val(S)	SUBWF	Param76,F	DECF	Param78,F	SKPNZ		;Was a single char string?	RETURN		; YesStrToMum_L1	CALL	Times10	mCall2To0	SRAM_ReadPI	MOVWF	Param79	MOVLW	'0'	;W=val(S)	SUBWF	Param79,W		ADDWF	Param76,F	ADDCF	Param77,F	DECFSZ	Param78,F	GOTO	StrToMum_L1	RETURN;Times10	MOVLW	d'9'	;loop 9 times	MOVWF	Param7B	MOVFW	Param76	MOVWF	Param79	MOVFW	Param77	MOVWF	Param7A;Times10_L1	MOVFW	Param79	ADDWF	Param76,F	ADDCF	Param77,F	MOVFW	Param7A	ADDWF	Param77,F	DECFSZ	Param7B,F	GOTO	Times10_L1	RETURN;;===============================================================================================; Kill the Default Text;; Entry: none; Exit: none; RAM used: none; Calls: (0) none;KillDefaultText	mBank0	BTFSS	UseDefaultText	RETURN	BCF	UseDefaultText	mBank3	CLRF	CharsInBuff	GOTO	MainBank0Rtn;;===============================================================================================; Adjust DispOffset to keep InsertionOffset visible;; Entry: ; Exit: ; RAM used: Param78; Calls: (0) none;DoAutoScroll	mBank3; if (InsertionOffset-DispOffset<0) then DispOffset--	MOVFW	DispOffset	SUBWF	InsertionOffset,W	MOVWF	Param78	;save for later	BPL	DoAutoScroll_1	;W is lost	DECF	DispOffset,F; if (InsertionOffset-DispOffset)>=(DispFieldWidth+DispXYPos) then DispOffset++DoAutoScroll_1	MOVFW	DispFieldWidth	ADDWF	DispXYPos,W	SUBWF	Param78,W	;ins-field	SKPNZ	GOTO	DoAutoScroll_2	BMI	DoAutoScroll_3; (InsertionOffset-DispOffset)=(DispFieldWidth+DispXYPos)DoAutoScroll_2	INCF	DispOffset,FDoAutoScroll_3	GOTO	MainBank0Rtn;;===============================================================================================; if CharsInBuff<MaxTextLen then CharsInBuff++; ; Entry: Bank3; Exit: Bank3; RAM used: none; Calls: (0) none;IncCharsInBuff	MOVF	MaxTextLen,W	SUBWF	CharsInBuff,W	;CharsInBuff-MaxTextLen	SKPNB		;MaxTextLen>CharsInBuff?	INCF	CharsInBuff,F	;Yes	RETURN;;===============================================================================================; if InsertionOffset<CharsInBuff then InsertionOffset++;; Entry: none; Exit: Bank3; RAM used: none; Calls: (0) none;IncInsOffset	mBank3	MOVF	CharsInBuff,W	SUBWF	InsertionOffset,W	;InsertionOffset-CharsInBuff	SKPNB		;CharsInBuff<=InsertionOffset?	INCF	InsertionOffset,F	;No	RETURN;;===============================================================================================; if InsertionOffset<>0 then InsertionOffset--;; Entry: none; Exit: Bank3; RAM used: none; Calls: (0) none;DecInsOffset	mBank3	TSTF	InsertionOffset	SKPZ		;InsertionOffset=0?	DECF	InsertionOffset,F	;No	RETURN;;===============================================================================================; Resets the auto-enter char timer for text entry;; Entry: none; Exit: none; RAM used: none; Calls: (0) none;RestartKeyTimer	mBank3	MOVLW	low kKeyTime	MOVWF	Timer2Lo	MOVLW	high kKeyTime	MOVWF	Timer2Hi	GOTO	MainBank0Rtn;;================================================================================================; Redraw the text in the buffer;; Entry: none; Exit: none; RAM used: Param75, Param76, Param77, Param78, Param79; Calls: (1+3) DoAutoScroll, RepositionCursor_1, SRAM_ReadPI_D10, DisplaysW_D10;RedrawText	CALL	DoAutoScroll	mBank3	MOVFW	DispXYPos	CALL	RepositionCursor_1	mBank3	MOVFW	DispOffset	;first char to display	MOVWF	Param77	CALL	AddressKeyboardBuff	;Bank3	MOVFW	DispFieldWidth	MOVWF	Param76	;CharsToDraw, 1..LCD_ChrsPerLine;; if DispOffset<CharsInBuff then DisplayCharRedrawText_L1	mBank3	MOVF	CharsInBuff,W	SUBWF	Param77,W	;DispOffset-CharsInBuff	SKPB		;CharsInBuff>DispOffset?	GOTO	RedrawText_1	;No	CALL	SRAM_ReadPI_D10	;ru:none	CALL	DisplaysW_D10	;ru:75,78,79	INCF	Param77,F	;DispOffset++	DECFSZ	Param76,F	;End of DispFieldWidth	GOTO	RedrawText_L1	;No;RedrawText_1	TSTF	Param76	SKPNZ	GOTO	RedrawText_2RedrawText_L2	CALL	Display_Space	;ru:75,78,79	DECFSZ	Param76,F	;End of DispFieldWidth	GOTO	RedrawText_L2	;No;RedrawText_2	if TestingKeyPadIO;tc	MOVLW	0x02	CALL	lcd_GotoLineW_D10	mBank3	MOVFW	CharsInBuff	LCall	Disp_decbyteW	CALL	Display_Space	mBank3	MOVFW	InsertionOffset	LCALL	Disp_decbyteW	;test puts 7th on stack;etc	endif;; fall through to RepositionCursor;;================================================================================================; Position Cursor on line 0 or 1; reposition cursor subtract 1 if CharsInBuff-MaxTextLen;; Entry:CharsInBuff, MaxTextLen, DispXYPos; Exit: none; RAM used: Param78, Param79 (verified 4/18/03); Calls: (1+1) lcd_gotoxy_NC_D10;RepositionCursor	mBank3	MOVFW	DispOffset	;normally 0x00	SUBWF	InsertionOffset,W	;W=InsertionOffset-DispXYPos	ADDWF	DispXYPos,WRepositionCursor_1	CLRF	Param78	;Line=0	mBank0	BTFSC	TextEntryLine1	INCF	Param78,F	;Line=1	GOTO	lcd_gotoxy_NC_D10;;================================================================================================; Delete a char at the insertion offset;; Entry: Param7B=char, InsertionOffset=Index; Exit: CharsInBuff--; RAM used: Param76, Param77, Param78, Param7A, Param7B; Calls: (1+2) IncCharsInBuff, SRAM_ReadPD_D10, SRAM_WritePI_D10;DeleteChar	mBank3	TSTF	CharsInBuff	SKPNZ		;CharsInBuff=0?	GOTO	MainBank0Rtn	;Yes;if InsertionOffset=CharsInBuff then //appending?	MOVFW	InsertionOffset	SUBWF	CharsInBuff,W	SKPZ		;InsertionOffset=CharsInBuff?	GOTO	DeleteChar_1	;NoDeleteChar_2	DECF	InsertionOffset,F	;  InsertionOffset--DeleteChar_3	DECF	CharsInBuff,F	;  CharsInBuff--	GOTO	MainBank0Rtn; for I=InsertionOffset to CharsInBuff-1;  Char(I)=Char(I+1); if InsertionOffset<>0 then InsertionOffset--; CharsInBuff--DeleteChar_1	INCF	InsertionOffset,W	;InsertionOffset+1	CALL	AddressKeyboardBuff	;Bank3	MOVFW	InsertionOffset	SUBWF	CharsInBuff,W	;W=CharsInBuff-InsertionOffset	MOVWF	Param76	; 1..MaxTextLenDeleteChar_L1	CALL	SRAM_ReadPD_D10	CALL	SRAM_WritePI_D10	CALL	SRAM_NextAddr_D10	DECFSZ	Param76,F	GOTO	DeleteChar_L1	mBank3	TSTF	InsertionOffset	SKPZ	GOTO	DeleteChar_2	GOTO	DeleteChar_3;;================================================================================================; Add a char to the buffer at the insertion offset;; Entry: Param7B=char, InsertionOffset=Index; Exit: CharsInBuff++; RAM used: Param76, Param77, Param78, Param79, Param7A, Param7B; Calls: (1+2) IncCharsInBuff, SRAM_Read_D10, SRAM_Write_D10;InsertChar	mBank3	MOVF	InsertionOffset,W	MOVWF	Param77	;Param77=InsertionOffset	CALL	AddressKeyboardBuff	;Bank3		MOVFW	CharsInBuff	MOVWF	Param76	;Param76=CharsInBuff++,EOD	CALL	IncCharsInBuff;InsertChar_L1	BCF	Param79,0	;CharMoved=False	MOVFW	Param76	SUBWF	Param77,W	SKPNZ		;InsertionOffset=EOD?	GOTO	InsertChar_1	;Yes;	INCF	Param77,F	;InsertionOffset++	CALL	SRAM_Read_D10	MOVWF	Param7A	BSF	Param79,0	;CharMoved=trueInsertChar_1	MOVF	Param7B,W	CALL	SRAM_WritePI_D10	BTFSS	Param79,0	;CharMoved?	RETURN		;No	MOVFW	Param7A	MOVWF	Param7B	GOTO	InsertChar_L1;;================================================================================================; Put the current char in the buffer at the current insertion offset;; Entry: Param7B=char, InsertionOffset=Index; Exit: none; RAM used: Param78, Param7B; Calls: (1+1) SRAM_Write_D10;BufferChar	mBank3	MOVF	InsertionOffset,W	CALL	AddressKeyboardBuff	;Bank3	MOVF	Param7B,W	GOTO	SRAM_Write_D10;;================================================================================================;Translate a Hex key value to an ascii value; Only 0..9 are used.;; Entry: Param7C=Hex(0..9); Exit: ascii in Param7B, Param7C is unchanged; RAM used: Param7C; Calls:(1+1) SRAM_Read;KeyToAlpha	mBank0	BTFSC	NumbersOnly	GOTO	KeyToAlpha_4	RLF	Param7C,W	;Param7B = 8 x Hex	MOVWF	Param7B	RLF	Param7B,F	RLF	Param7B,F	MOVLW	0x78	ANDWF	Param7B,F	;clr unwanted bits;	BTFSS	FirstPass	GOTO	KeyToAlpha_2KeyToAlpha_1	mBank3	CLRF	KeyDataOffset	CLRW	GOTO	KeyToAlpha_3;KeyToAlpha_2	mBank3	INCF	KeyDataOffset,F	MOVLW	0x07	;8 chars per key	ANDWF	KeyDataOffset,F	MOVF	KeyDataOffset,W	;0..7KeyToAlpha_3	ADDWF	Param7B,W	;0..79	ADDLW	low KeyData;	mCall2To0	SRAM_ReadDR	SKPNZ		;valid data?	GOTO	KeyToAlpha_1	;NO	MOVWF	Param7B	BTFSC	UpperCase	;Uppercase?	RETURN		;Yes	SUBLW	0x40	;No, 0x40-Char	SKPB		;<'A'? Not Borrowed?	RETURN		;Yes	MOVLW	'Z'	SUBWF	Param7B,W	;Char-'Z'	SKPB		;<='Z'?  Borrowed?	RETURN		;No, 	MOVLW	0x20	;Chr=Chr+0x20,	ADDWF	Param7B,F	; make lower case	RETURN;KeyToAlpha_4	MOVLW	'0'	ADDWF	Param7C,W	MOVWF	Param7B	mBank3	MOVLW	0xFF	;LastKeyDown=0xFF	MOVWF	LastKeyDown	GOTO	MainBank0Rtn;;;============================================================================================; Setup SRAM_Addr to evKeyboardBuff+W (3);; Entry: W=offset; Exit: SRAM_Addr=evKeyboardBuff+W, bank3; RAM used: none; Calls: (0) none;AddressKeyboardBuff	mBank3	MOVWF	SRAM_Addr0	MOVLW	low evKeyboardBuff	MOVWF	SRAM_Addr1	MOVLW	high evKeyboardBuff	MOVWF	SRAM_Addr2	RETURN;;================================================================================================; Special Character selection mode routines;; There are 23 Special Chars;	MOVFW	SpeclChrOffset	;0..23;	ADDLW	SpecialChars;	mCall2To0	SRAM_ReadDR	;get the char;;;;;;;;;;;;;;;;;